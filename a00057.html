<!-- HTML header for doxygen 1.9.5-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>bRAWcap: Transmit</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="1_doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="2_bplus_generic_extensions.css" rel="stylesheet" type="text/css"/>
<!-- BEGIN BPLUS MODIFICATIONS -->
<!-- Load and initialize used doxygen extensions -->
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeParagraphLink.init()
</script>
<!-- We use a sticky navigation header - therefore we have to handle the header offset while scrolling and linking -->
<script type="text/javascript">
    // Fix offset due to sticky top (navigation)
    function UpdateHeaderOffset(){
      var headerEl = document.getElementById("top");
      var headerHeight = +headerEl.offsetHeight;
      document.documentElement.style.scrollPaddingTop = headerHeight + 'px';
    }
    // Fix offset and scroll to anchor if page is loaded with anchor url.
    function ScrollToAnchorOnLoad(){
      UpdateHeaderOffset();
      var anchor = document.getElementById(window.location.hash.substr(1))
      if(anchor){
        anchor.scrollIntoView();
      }
    }
    // Add listeners for updating our sticky header offset...
    document.addEventListener('DOMNodeInserted', ScrollToAnchorOnLoad);
    window.addEventListener('resize', UpdateHeaderOffset);
</script>
<!-- END BPLUS MODIFICATIONS -->
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="bplus_logo.svg"/></td>
  <td id="projectalign">
   <div id="projectname">bRAWcap<span id="projectnumber">&#160;1.0.1</span>
   </div>
   <div id="projectbrief">b-plus Technologies - Ethernet Performance Transmitter Receiver</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Transmit</div></div>
</div><!--header-->
<div class="contents">

<p>Types and functions for bRAWcap transmitting.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga853277dc3cad27d1c64a0d9478412cfa"><td class="memItemLeft" align="right" valign="top"><a id="ga853277dc3cad27d1c64a0d9478412cfa" name="ga853277dc3cad27d1c64a0d9478412cfa"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BRAWCAP_TX_DRIVER_QUEUE_SIZE_DEFAULT</b>&#160;&#160;&#160;512</td></tr>
<tr class="memdesc:ga853277dc3cad27d1c64a0d9478412cfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default size in number of packets for driver transmit queues. <br /></td></tr>
<tr class="separator:ga853277dc3cad27d1c64a0d9478412cfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7f2ba7abbbb545bd073350bde487131"><td class="memItemLeft" align="right" valign="top"><a id="gac7f2ba7abbbb545bd073350bde487131" name="gac7f2ba7abbbb545bd073350bde487131"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BRAWCAP_TX_DRIVER_QUEUE_SIZE_MIN</b>&#160;&#160;&#160;256</td></tr>
<tr class="memdesc:gac7f2ba7abbbb545bd073350bde487131"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum size in number of packets supported for driver transmit queues. <br /></td></tr>
<tr class="separator:gac7f2ba7abbbb545bd073350bde487131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48f039f7f04d5d2e7cfb6423675cecb8"><td class="memItemLeft" align="right" valign="top"><a id="ga48f039f7f04d5d2e7cfb6423675cecb8" name="ga48f039f7f04d5d2e7cfb6423675cecb8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BRAWCAP_TX_DRIVER_QUEUE_SIZE_MAX</b>&#160;&#160;&#160;4096</td></tr>
<tr class="memdesc:ga48f039f7f04d5d2e7cfb6423675cecb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum size in number of packets supported for driver transmit queues. <br /></td></tr>
<tr class="separator:ga48f039f7f04d5d2e7cfb6423675cecb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83a90a39735fb98994c5438257cd450b"><td class="memItemLeft" align="right" valign="top"><a id="ga83a90a39735fb98994c5438257cd450b" name="ga83a90a39735fb98994c5438257cd450b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BRAWCAP_TX_TIMESTAMP_MODE_DEFAULT</b>&#160;&#160;&#160;<a class="el" href="a00050.html#gga98151584e36542e2e1f0defff54cb4f9aaad72387aa1091d4919e52efa0cca37f">BRAWCAP_TIMESTAMP_MODE_NO_TIMESTAMP</a></td></tr>
<tr class="memdesc:ga83a90a39735fb98994c5438257cd450b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default timestamp mode for transmitted packets. <br /></td></tr>
<tr class="separator:ga83a90a39735fb98994c5438257cd450b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gad3ffbb6bf21ee4d4ea04296516996378"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00057.html#gad3ffbb6bf21ee4d4ea04296516996378">brawcap_tx_callback_t</a>) (<a class="el" href="a00047.html#ga671085eed0374e88951b853f9eb027c1">brawcap_handle_t</a> *const pHandle, const <a class="el" href="a00048.html#ga9c7e2713c1673acb5aab7c2d06ff481f">brawcap_status_t</a> status, <a class="el" href="a00052.html#ga0b3e0af30a05c842f801a981ffd19582">brawcap_buffer_t</a> *const pBuffer, void *pUser)</td></tr>
<tr class="memdesc:gad3ffbb6bf21ee4d4ea04296516996378"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmit callback which is called each time a transmission initiated with <a class="el" href="a00057.html#gaf45c0802b4ddb91078215bb020d9c6f1">brawcap_tx_buffer_send</a> has finished.  <br /></td></tr>
<tr class="separator:gad3ffbb6bf21ee4d4ea04296516996378"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga865daff99e776de6c90f2d09d0672e66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00048.html#ga9c7e2713c1673acb5aab7c2d06ff481f">brawcap_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00057.html#ga865daff99e776de6c90f2d09d0672e66">brawcap_tx_packet</a> (<a class="el" href="a00047.html#ga671085eed0374e88951b853f9eb027c1">brawcap_handle_t</a> *const pHandle, <a class="el" href="a00051.html#ga840aa22feee3a992bafe63f3653afbf7">brawcap_packet_t</a> *const pPacket)</td></tr>
<tr class="memdesc:ga865daff99e776de6c90f2d09d0672e66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmits a single packet on the specified handle.  <br /></td></tr>
<tr class="separator:ga865daff99e776de6c90f2d09d0672e66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccf4524e95ded50eff71f5e42d14e894"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00048.html#ga9c7e2713c1673acb5aab7c2d06ff481f">brawcap_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00057.html#gaccf4524e95ded50eff71f5e42d14e894">brawcap_tx_start</a> (<a class="el" href="a00047.html#ga671085eed0374e88951b853f9eb027c1">brawcap_handle_t</a> *const pHandle, <a class="el" href="a00057.html#gad3ffbb6bf21ee4d4ea04296516996378">brawcap_tx_callback_t</a> const callback, void *pUser)</td></tr>
<tr class="memdesc:gaccf4524e95ded50eff71f5e42d14e894"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts the internal transmit loop.  <br /></td></tr>
<tr class="separator:gaccf4524e95ded50eff71f5e42d14e894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98edfaad9410cdb929d03d7fc50491fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00048.html#ga9c7e2713c1673acb5aab7c2d06ff481f">brawcap_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00057.html#ga98edfaad9410cdb929d03d7fc50491fc">brawcap_tx_stop</a> (<a class="el" href="a00047.html#ga671085eed0374e88951b853f9eb027c1">brawcap_handle_t</a> *const pHandle)</td></tr>
<tr class="memdesc:ga98edfaad9410cdb929d03d7fc50491fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops the internal transmit loop.  <br /></td></tr>
<tr class="separator:ga98edfaad9410cdb929d03d7fc50491fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf45c0802b4ddb91078215bb020d9c6f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00048.html#ga9c7e2713c1673acb5aab7c2d06ff481f">brawcap_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00057.html#gaf45c0802b4ddb91078215bb020d9c6f1">brawcap_tx_buffer_send</a> (<a class="el" href="a00047.html#ga671085eed0374e88951b853f9eb027c1">brawcap_handle_t</a> *const pHandle, <a class="el" href="a00052.html#ga0b3e0af30a05c842f801a981ffd19582">brawcap_buffer_t</a> *const pBuffer, const BOOLEAN synchronized)</td></tr>
<tr class="memdesc:gaf45c0802b4ddb91078215bb020d9c6f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes the specified buffer to the specified handle transmit queue.  <br /></td></tr>
<tr class="separator:gaf45c0802b4ddb91078215bb020d9c6f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf34f95e9f9b64a4954ca4e975c03a955"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00048.html#ga9c7e2713c1673acb5aab7c2d06ff481f">brawcap_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00057.html#gaf34f95e9f9b64a4954ca4e975c03a955">brawcap_tx_driver_queue_size_set</a> (<a class="el" href="a00047.html#ga671085eed0374e88951b853f9eb027c1">brawcap_handle_t</a> *const pHandle, const <a class="el" href="a00047.html#ga5333ed197831fcb54dc690a993eb7310">brawcap_queue_size_t</a> size)</td></tr>
<tr class="memdesc:gaf34f95e9f9b64a4954ca4e975c03a955"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the driver queue size (in number of packets) for the specified handle.  <br /></td></tr>
<tr class="separator:gaf34f95e9f9b64a4954ca4e975c03a955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26b62182aa30e2caa7e1387026e852b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00048.html#ga9c7e2713c1673acb5aab7c2d06ff481f">brawcap_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00057.html#ga26b62182aa30e2caa7e1387026e852b2">brawcap_tx_driver_queue_size_get</a> (<a class="el" href="a00047.html#ga671085eed0374e88951b853f9eb027c1">brawcap_handle_t</a> *const pHandle, <a class="el" href="a00047.html#ga5333ed197831fcb54dc690a993eb7310">brawcap_queue_size_t</a> *const pSize)</td></tr>
<tr class="memdesc:ga26b62182aa30e2caa7e1387026e852b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads out the currently configured driver transmit queue size for the specified handle.  <br /></td></tr>
<tr class="separator:ga26b62182aa30e2caa7e1387026e852b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b21547ad98505294a1aaba9c14dddf7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00048.html#ga9c7e2713c1673acb5aab7c2d06ff481f">brawcap_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00057.html#ga2b21547ad98505294a1aaba9c14dddf7">brawcap_tx_timestamp_capabilities</a> (<a class="el" href="a00047.html#ga671085eed0374e88951b853f9eb027c1">brawcap_handle_t</a> *const pHandle, <a class="el" href="a00050.html#ga2e576ed8155bf55660489ea9406a69d5">brawcap_timestamp_capabilities_t</a> *const pCapabilities)</td></tr>
<tr class="memdesc:ga2b21547ad98505294a1aaba9c14dddf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads out the available transmit timestamp modes for the specified handle.  <br /></td></tr>
<tr class="separator:ga2b21547ad98505294a1aaba9c14dddf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga891738aa12943e96168a1cb48427ebce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00048.html#ga9c7e2713c1673acb5aab7c2d06ff481f">brawcap_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00057.html#ga891738aa12943e96168a1cb48427ebce">brawcap_tx_timestamp_mode_set</a> (<a class="el" href="a00047.html#ga671085eed0374e88951b853f9eb027c1">brawcap_handle_t</a> *const pHandle, const <a class="el" href="a00050.html#ga98151584e36542e2e1f0defff54cb4f9">brawcap_timestamp_mode_t</a> mode)</td></tr>
<tr class="memdesc:ga891738aa12943e96168a1cb48427ebce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the used transmit time stamping mode for the specified handle.  <br /></td></tr>
<tr class="separator:ga891738aa12943e96168a1cb48427ebce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8dc16541db414167f51ff69fc52ed7d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00048.html#ga9c7e2713c1673acb5aab7c2d06ff481f">brawcap_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00057.html#ga8dc16541db414167f51ff69fc52ed7d3">brawcap_tx_timestamp_mode_get</a> (<a class="el" href="a00047.html#ga671085eed0374e88951b853f9eb027c1">brawcap_handle_t</a> *const pHandle, <a class="el" href="a00050.html#ga98151584e36542e2e1f0defff54cb4f9">brawcap_timestamp_mode_t</a> *const pMode)</td></tr>
<tr class="memdesc:ga8dc16541db414167f51ff69fc52ed7d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads out the currently configured transmit time stamping mode for the specified handle.  <br /></td></tr>
<tr class="separator:ga8dc16541db414167f51ff69fc52ed7d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Types and functions for bRAWcap transmitting. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gad3ffbb6bf21ee4d4ea04296516996378" name="gad3ffbb6bf21ee4d4ea04296516996378"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad3ffbb6bf21ee4d4ea04296516996378">&#9670;&#160;</a></span>brawcap_tx_callback_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* brawcap_tx_callback_t) (<a class="el" href="a00047.html#ga671085eed0374e88951b853f9eb027c1">brawcap_handle_t</a> *const pHandle, const <a class="el" href="a00048.html#ga9c7e2713c1673acb5aab7c2d06ff481f">brawcap_status_t</a> status, <a class="el" href="a00052.html#ga0b3e0af30a05c842f801a981ffd19582">brawcap_buffer_t</a> *const pBuffer, void *pUser)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="a00041.html">brawcap_types_um.h</a>&gt;</code></p>

<p>Transmit callback which is called each time a transmission initiated with <a class="el" href="a00057.html#gaf45c0802b4ddb91078215bb020d9c6f1">brawcap_tx_buffer_send</a> has finished. </p>
<dl class="section note"><dt>Note</dt><dd>Before any buffer can be transmitted the tranmission has to be started with <a class="el" href="a00057.html#gaccf4524e95ded50eff71f5e42d14e894">brawcap_tx_start</a> and stopped with <a class="el" href="a00057.html#ga98edfaad9410cdb929d03d7fc50491fc">brawcap_tx_stop</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pHandle</td><td>Handle on which the transmission has finished.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">status</td><td>The overall transmission status see <a class="el" href="a00048.html#ga9c7e2713c1673acb5aab7c2d06ff481f">brawcap_status_t</a> for possible return values.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pBuffer</td><td>Pointer to the buffer which has finished transmission (initiated with <a class="el" href="a00057.html#gaf45c0802b4ddb91078215bb020d9c6f1">brawcap_tx_buffer_send</a>). It can be used to access all packets in the buffer - after transmission - and allows to retrieve information about each packet (e.g. (transmission) status, timestamp, ...).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pUser</td><td>Pointer to a user defined context (allows access to user specific data within the callback). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga865daff99e776de6c90f2d09d0672e66" name="ga865daff99e776de6c90f2d09d0672e66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga865daff99e776de6c90f2d09d0672e66">&#9670;&#160;</a></span>brawcap_tx_packet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00048.html#ga9c7e2713c1673acb5aab7c2d06ff481f">brawcap_status_t</a> brawcap_tx_packet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00047.html#ga671085eed0374e88951b853f9eb027c1">brawcap_handle_t</a> *const&#160;</td>
          <td class="paramname"><em>pHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00051.html#ga840aa22feee3a992bafe63f3653afbf7">brawcap_packet_t</a> *const&#160;</td>
          <td class="paramname"><em>pPacket</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="a00035.html">brawcap.h</a>&gt;</code></p>

<p>Transmits a single packet on the specified handle. </p>
<p>The caller must provide a valid packet filled up with the payload to transmit.</p>
<p>For creating a packet use <a class="el" href="a00051.html#ga68e198e3b23bb01fe147fa4f29760e03">brawcap_packet_create</a>. After creating the packet set all the required packet fields and than call this function to initiate a transmission.</p>
<p>When transmission has finished (the function returns) the packet fields are updated.</p>
<p>To check if the transmission was successful check for the function return status or the packet status itself with <a class="el" href="a00051.html#gadb972f95c4392ed92447e0f47850bc94">brawcap_packet_status_get</a>. If the packet was transmitted and transmit time stamping was enabled the packet timestamp will contain the transmission time, which be accessed with <a class="el" href="a00051.html#gaec95a9ac6864a74bf61373ae4dabb12a">brawcap_packet_timestamp_get</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pHandle</td><td>bRAWcap handle to transmit on.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pPacket</td><td>Packet to be transmitted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Status   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="a00048.html#gga9c7e2713c1673acb5aab7c2d06ff481fa200dd935b65622249463189f7a6caf32">BRAWCAP_STATUS_SUCCESS</a>   </td><td class="markdownTableBodyNone">Success.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="a00048.html#gga9c7e2713c1673acb5aab7c2d06ff481fa67cb41d5c4f828e746e586da186436ce">BRAWCAP_STATUS_ERROR_INVALID_POINTER</a>   </td><td class="markdownTableBodyNone">At least one of the given pointer parameters was invalid.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="a00048.html#gga9c7e2713c1673acb5aab7c2d06ff481fa1df8bf6b3b7171107e611a28c1148d02">BRAWCAP_STATUS_ERROR_DRIVER_NOT_AVAILABLE</a>   </td><td class="markdownTableBodyNone">bRAWcap driver is not active (anymore) on the adapter.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="a00048.html#gga9c7e2713c1673acb5aab7c2d06ff481faf67498d12e585323c9dd217f39d0cf46">BRAWCAP_STATUS_WARNING_DEMO_MODE</a>   </td><td class="markdownTableBodyNone">Running in demo mode (no license).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="a00048.html#gga9c7e2713c1673acb5aab7c2d06ff481fa318dec04646ebef9e4ec33318790bb17">BRAWCAP_STATUS_ERROR_DRIVER_IO_FAILED</a>   </td><td class="markdownTableBodyNone">Communicating with bRAWcap driver failed.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="a00048.html#gga9c7e2713c1673acb5aab7c2d06ff481fafe9ee8ab44218ff239135d176d0c1316">BRAWCAP_STATUS_WARNING_NOT_ALL_PROCESSED</a>   </td><td class="markdownTableBodyNone">The transmission failed (or payload was not fully transmitted).   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="gaccf4524e95ded50eff71f5e42d14e894" name="gaccf4524e95ded50eff71f5e42d14e894"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaccf4524e95ded50eff71f5e42d14e894">&#9670;&#160;</a></span>brawcap_tx_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00048.html#ga9c7e2713c1673acb5aab7c2d06ff481f">brawcap_status_t</a> brawcap_tx_start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00047.html#ga671085eed0374e88951b853f9eb027c1">brawcap_handle_t</a> *const&#160;</td>
          <td class="paramname"><em>pHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00057.html#gad3ffbb6bf21ee4d4ea04296516996378">brawcap_tx_callback_t</a> const&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pUser</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="a00035.html">brawcap.h</a>&gt;</code></p>

<p>Starts the internal transmit loop. </p>
<p>To transmit data using this method push previously filled packet buffers to the handle by using <a class="el" href="a00057.html#gaf45c0802b4ddb91078215bb020d9c6f1">brawcap_tx_buffer_send</a>. After that the buffer will be locked down by the handle and added to it´s transmission queue.</p>
<p>For creating a new packet buffer which can be used for transmission use <a class="el" href="a00052.html#gad26a018bb4c368265d829e0f9532f301">brawcap_buffer_create</a>.</p>
<p>When a packet buffer transmission has completed the <a class="el" href="a00057.html#gad3ffbb6bf21ee4d4ea04296516996378">transmit callback</a> will be called for this handle and with the corresponding packet buffer. From within the callback the buffer can be accessed for post processing (it is unlocked before entering the callback). It is also possible to do post processing from a different thread and after the callback.</p>
<p>In general executing to long in the callback can lead to a bottleneck in the transmission. It´s not as critical as it is for receiving but it should be still kept in mind.</p>
<p>Like <a class="el" href="a00057.html#ga865daff99e776de6c90f2d09d0672e66">brawcap_tx_packet</a> does, also each packet in transmitted packet buffers will be updated (e.g. packet status, transmission timestamp). The user application can access those updated information after transmission has completed.</p>
<p>A completed packet buffer transmission will automatically detach the buffer from the handle. It is not needed to detach it explicitly (which would be required for receive buffers).</p>
<dl class="section note"><dt>Note</dt><dd>The buffers are transmitted in the same order they have been added by the user application with <a class="el" href="a00057.html#gaf45c0802b4ddb91078215bb020d9c6f1">brawcap_tx_buffer_send</a>.</dd></dl>
<dl class="section invariant"><dt>Invariant</dt><dd>The user parameter allows access to user defined context. The given pointer is not used and validated by bRAWcap. Therefore the user is responsible for validating the context in the callback before accessing it.</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>After starting transmission, <a class="el" href="a00057.html#ga865daff99e776de6c90f2d09d0672e66">brawcap_tx_packet</a> can not be used - on this handle - until tranmission is stopped with <a class="el" href="a00057.html#ga98edfaad9410cdb929d03d7fc50491fc">brawcap_tx_stop</a>, because parallel transmissions are not allowed</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pHandle</td><td>bRAWcap handle to transmit on.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>Function pointer to user application transmit callback.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pUser</td><td>Pointer to a user defined context. Can be NULL if no user context is required.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Status   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="a00048.html#gga9c7e2713c1673acb5aab7c2d06ff481fa200dd935b65622249463189f7a6caf32">BRAWCAP_STATUS_SUCCESS</a>   </td><td class="markdownTableBodyNone">Success.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="a00048.html#gga9c7e2713c1673acb5aab7c2d06ff481fa67cb41d5c4f828e746e586da186436ce">BRAWCAP_STATUS_ERROR_INVALID_POINTER</a>   </td><td class="markdownTableBodyNone">At least one of the given pointer parameters was invalid.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="a00048.html#gga9c7e2713c1673acb5aab7c2d06ff481fa7b5947d7cb66cf12afc410f255622eed">BRAWCAP_STATUS_WARNING_PENDING</a>   </td><td class="markdownTableBodyNone">Another transmit is pending or transmission is already started.   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="ga98edfaad9410cdb929d03d7fc50491fc" name="ga98edfaad9410cdb929d03d7fc50491fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98edfaad9410cdb929d03d7fc50491fc">&#9670;&#160;</a></span>brawcap_tx_stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00048.html#ga9c7e2713c1673acb5aab7c2d06ff481f">brawcap_status_t</a> brawcap_tx_stop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00047.html#ga671085eed0374e88951b853f9eb027c1">brawcap_handle_t</a> *const&#160;</td>
          <td class="paramname"><em>pHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="a00035.html">brawcap.h</a>&gt;</code></p>

<p>Stops the internal transmit loop. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pHandle</td><td>bRAWcap handle to stop transmission on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Status   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="a00048.html#gga9c7e2713c1673acb5aab7c2d06ff481fa200dd935b65622249463189f7a6caf32">BRAWCAP_STATUS_SUCCESS</a>   </td><td class="markdownTableBodyNone">Success.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="a00048.html#gga9c7e2713c1673acb5aab7c2d06ff481fa67cb41d5c4f828e746e586da186436ce">BRAWCAP_STATUS_ERROR_INVALID_POINTER</a>   </td><td class="markdownTableBodyNone">At least one of the given pointer parameters was invalid.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="a00048.html#gga9c7e2713c1673acb5aab7c2d06ff481fac093309781dc2e9b9932dbc40c511f68">BRAWCAP_STATUS_INFO_NOT_RUNNING</a>   </td><td class="markdownTableBodyNone">There was no transmission running.   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="gaf45c0802b4ddb91078215bb020d9c6f1" name="gaf45c0802b4ddb91078215bb020d9c6f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf45c0802b4ddb91078215bb020d9c6f1">&#9670;&#160;</a></span>brawcap_tx_buffer_send()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00048.html#ga9c7e2713c1673acb5aab7c2d06ff481f">brawcap_status_t</a> brawcap_tx_buffer_send </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00047.html#ga671085eed0374e88951b853f9eb027c1">brawcap_handle_t</a> *const&#160;</td>
          <td class="paramname"><em>pHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00052.html#ga0b3e0af30a05c842f801a981ffd19582">brawcap_buffer_t</a> *const&#160;</td>
          <td class="paramname"><em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BOOLEAN&#160;</td>
          <td class="paramname"><em>synchronized</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="a00035.html">brawcap.h</a>&gt;</code></p>

<p>Pushes the specified buffer to the specified handle transmit queue. </p>
<p>After pushing a packet buffer to the handle for transmission it is locked down by the handle until transmission has completed (and the <a class="el" href="a00057.html#gad3ffbb6bf21ee4d4ea04296516996378">transmit callback</a> is called).</p>
<p>With the synchronized flag it is possible to activate a synchronized transmission of the specified packet buffer. This means that the driver reads the time gap between each packet in the packet buffer and waits until it has been elapsed before initiating transmission.</p>
<dl class="section attention"><dt>Attention</dt><dd>For synchronized transmission it is necessary to sort the packets in the buffer by rising timestamp. Furthermore, it is currently not supported to specify a "start time" when the first packet should be transmitted. Therefore if you want to start transmission depending on the first packet timestamp you should wait until the time is reached and after this initiate the transmission by calling this function. The driver itself only evaluates the time gaps between each packet in the buffer.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Packet buffers are transmitted in the same order they was pushed to the handle.</dd></dl>
<dl class="section invariant"><dt>Invariant</dt><dd>Keep in mind that the packet timestamp is updated after transmission has been completed by the transmission timestamp (depending on the configured timestamp mode). Therefore if there was a packet timestamp set for example to send synchronized, this timestamp will be overwritten.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pHandle</td><td>bRAWcap handle for sending the buffer.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pBuffer</td><td>Packet buffer to be sent.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">synchronized</td><td>Flag indicating if the packets in the packet buffer should be sent synchronized.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Status   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="a00048.html#gga9c7e2713c1673acb5aab7c2d06ff481fa200dd935b65622249463189f7a6caf32">BRAWCAP_STATUS_SUCCESS</a>   </td><td class="markdownTableBodyNone">Success.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="a00048.html#gga9c7e2713c1673acb5aab7c2d06ff481fa67cb41d5c4f828e746e586da186436ce">BRAWCAP_STATUS_ERROR_INVALID_POINTER</a>   </td><td class="markdownTableBodyNone">At least one of the given pointer parameters was invalid.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="a00048.html#gga9c7e2713c1673acb5aab7c2d06ff481fa1483743d4d66e1546756da1313b62edf">BRAWCAP_STATUS_ERROR_IN_USE</a>   </td><td class="markdownTableBodyNone">The buffer is already in use / locked down by another operation.   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="gaf34f95e9f9b64a4954ca4e975c03a955" name="gaf34f95e9f9b64a4954ca4e975c03a955"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf34f95e9f9b64a4954ca4e975c03a955">&#9670;&#160;</a></span>brawcap_tx_driver_queue_size_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00048.html#ga9c7e2713c1673acb5aab7c2d06ff481f">brawcap_status_t</a> brawcap_tx_driver_queue_size_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00047.html#ga671085eed0374e88951b853f9eb027c1">brawcap_handle_t</a> *const&#160;</td>
          <td class="paramname"><em>pHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00047.html#ga5333ed197831fcb54dc690a993eb7310">brawcap_queue_size_t</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="a00035.html">brawcap.h</a>&gt;</code></p>

<p>Sets the driver queue size (in number of packets) for the specified handle. </p>
<p>For transmission the driver queue size may be increased if high data rates should be reached (for example 10GBit/s). With a larger transmission queue the driver can forward more packets to the network adapter at the same time. Therefore if the transmission rate is below the expected value it may be solved by a larger driver queue size.</p>
<p>The driver queue size can be adjusted at any time.</p>
<dl class="section note"><dt>Note</dt><dd>The default queue size is </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00057.html#ga853277dc3cad27d1c64a0d9478412cfa" title="Default size in number of packets for driver transmit queues.">BRAWCAP_TX_DRIVER_QUEUE_SIZE_DEFAULT</a> (in number of packets). And its max limitation is </dd>
<dd>
<a class="el" href="a00057.html#ga48f039f7f04d5d2e7cfb6423675cecb8" title="Maximum size in number of packets supported for driver transmit queues.">BRAWCAP_TX_DRIVER_QUEUE_SIZE_MAX</a> (in number of packets).</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Reducing the queue size during runtime may result in packet transmission cancellation. This may be the case if there are more packets pending for transmission than the new size can accommodate.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pHandle</td><td>bRAWcap handle to be configured.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Driver transmit queue size to be set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Status   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="a00048.html#gga9c7e2713c1673acb5aab7c2d06ff481fa200dd935b65622249463189f7a6caf32">BRAWCAP_STATUS_SUCCESS</a>   </td><td class="markdownTableBodyNone">Success.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="a00048.html#gga9c7e2713c1673acb5aab7c2d06ff481fa67cb41d5c4f828e746e586da186436ce">BRAWCAP_STATUS_ERROR_INVALID_POINTER</a>   </td><td class="markdownTableBodyNone">At least one of the given pointer parameters was invalid.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="a00048.html#gga9c7e2713c1673acb5aab7c2d06ff481fa5e8c73946b04c321cd81cdd35d2d812e">BRAWCAP_STATUS_ERROR_PARAM_OUT_OF_RANGE</a>   </td><td class="markdownTableBodyNone">Specified queue size is out of range/invalid.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="a00048.html#gga9c7e2713c1673acb5aab7c2d06ff481fa318dec04646ebef9e4ec33318790bb17">BRAWCAP_STATUS_ERROR_DRIVER_IO_FAILED</a>   </td><td class="markdownTableBodyNone">Communicating with bRAWcap driver failed.   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="ga26b62182aa30e2caa7e1387026e852b2" name="ga26b62182aa30e2caa7e1387026e852b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga26b62182aa30e2caa7e1387026e852b2">&#9670;&#160;</a></span>brawcap_tx_driver_queue_size_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00048.html#ga9c7e2713c1673acb5aab7c2d06ff481f">brawcap_status_t</a> brawcap_tx_driver_queue_size_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00047.html#ga671085eed0374e88951b853f9eb027c1">brawcap_handle_t</a> *const&#160;</td>
          <td class="paramname"><em>pHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00047.html#ga5333ed197831fcb54dc690a993eb7310">brawcap_queue_size_t</a> *const&#160;</td>
          <td class="paramname"><em>pSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="a00035.html">brawcap.h</a>&gt;</code></p>

<p>Reads out the currently configured driver transmit queue size for the specified handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pHandle</td><td>bRAWcap handle to read from.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pSize</td><td>Will contain the currently configured driver transmit queue size, afterwards.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Status   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="a00048.html#gga9c7e2713c1673acb5aab7c2d06ff481fa200dd935b65622249463189f7a6caf32">BRAWCAP_STATUS_SUCCESS</a>   </td><td class="markdownTableBodyNone">Success.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="a00048.html#gga9c7e2713c1673acb5aab7c2d06ff481fa67cb41d5c4f828e746e586da186436ce">BRAWCAP_STATUS_ERROR_INVALID_POINTER</a>   </td><td class="markdownTableBodyNone">At least one of the given pointer parameters was invalid.   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="ga2b21547ad98505294a1aaba9c14dddf7" name="ga2b21547ad98505294a1aaba9c14dddf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b21547ad98505294a1aaba9c14dddf7">&#9670;&#160;</a></span>brawcap_tx_timestamp_capabilities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00048.html#ga9c7e2713c1673acb5aab7c2d06ff481f">brawcap_status_t</a> brawcap_tx_timestamp_capabilities </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00047.html#ga671085eed0374e88951b853f9eb027c1">brawcap_handle_t</a> *const&#160;</td>
          <td class="paramname"><em>pHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00050.html#ga2e576ed8155bf55660489ea9406a69d5">brawcap_timestamp_capabilities_t</a> *const&#160;</td>
          <td class="paramname"><em>pCapabilities</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="a00035.html">brawcap.h</a>&gt;</code></p>

<p>Reads out the available transmit timestamp modes for the specified handle. </p>
<p>Some of the timestamp capabilities depend on the features provided by the underlying adapter. Those modes are named with "adapter".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pHandle</td><td>bRAWcap handle to read from.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pCapabilities</td><td>Will contain the available transmit timestamp modes, afterwards.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Status   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="a00048.html#gga9c7e2713c1673acb5aab7c2d06ff481fa200dd935b65622249463189f7a6caf32">BRAWCAP_STATUS_SUCCESS</a>   </td><td class="markdownTableBodyNone">Success.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="a00048.html#gga9c7e2713c1673acb5aab7c2d06ff481fa67cb41d5c4f828e746e586da186436ce">BRAWCAP_STATUS_ERROR_INVALID_POINTER</a>   </td><td class="markdownTableBodyNone">At least one of the given pointer parameters was invalid.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="a00048.html#gga9c7e2713c1673acb5aab7c2d06ff481fa318dec04646ebef9e4ec33318790bb17">BRAWCAP_STATUS_ERROR_DRIVER_IO_FAILED</a>   </td><td class="markdownTableBodyNone">Communicating with bRAWcap driver failed.   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="ga891738aa12943e96168a1cb48427ebce" name="ga891738aa12943e96168a1cb48427ebce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga891738aa12943e96168a1cb48427ebce">&#9670;&#160;</a></span>brawcap_tx_timestamp_mode_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00048.html#ga9c7e2713c1673acb5aab7c2d06ff481f">brawcap_status_t</a> brawcap_tx_timestamp_mode_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00047.html#ga671085eed0374e88951b853f9eb027c1">brawcap_handle_t</a> *const&#160;</td>
          <td class="paramname"><em>pHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00050.html#ga98151584e36542e2e1f0defff54cb4f9">brawcap_timestamp_mode_t</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="a00035.html">brawcap.h</a>&gt;</code></p>

<p>Configures the used transmit time stamping mode for the specified handle. </p>
<dl class="section note"><dt>Note</dt><dd>Only available timestamp modes are accepted. It is recommended to check if a timestamp mode is supported before setting it. To check if a timestamp mode is available use <a class="el" href="a00057.html#ga2b21547ad98505294a1aaba9c14dddf7">brawcap_tx_timestamp_capabilities</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pHandle</td><td>bRAWcap handle to be configured.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>The transmit timestamp mode to be configured.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Status   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="a00048.html#gga9c7e2713c1673acb5aab7c2d06ff481fa200dd935b65622249463189f7a6caf32">BRAWCAP_STATUS_SUCCESS</a>   </td><td class="markdownTableBodyNone">Success.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="a00048.html#gga9c7e2713c1673acb5aab7c2d06ff481fa67cb41d5c4f828e746e586da186436ce">BRAWCAP_STATUS_ERROR_INVALID_POINTER</a>   </td><td class="markdownTableBodyNone">At least one of the given pointer parameters was invalid.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="a00048.html#gga9c7e2713c1673acb5aab7c2d06ff481facf0a3e5a7707d6dffe88cb1f22e14c30">BRAWCAP_STATUS_ERROR_NOT_AVAILABLE</a>   </td><td class="markdownTableBodyNone">Specified timestamp mode not available.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="a00048.html#gga9c7e2713c1673acb5aab7c2d06ff481fa318dec04646ebef9e4ec33318790bb17">BRAWCAP_STATUS_ERROR_DRIVER_IO_FAILED</a>   </td><td class="markdownTableBodyNone">Communicating with bRAWcap driver failed.   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="ga8dc16541db414167f51ff69fc52ed7d3" name="ga8dc16541db414167f51ff69fc52ed7d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8dc16541db414167f51ff69fc52ed7d3">&#9670;&#160;</a></span>brawcap_tx_timestamp_mode_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00048.html#ga9c7e2713c1673acb5aab7c2d06ff481f">brawcap_status_t</a> brawcap_tx_timestamp_mode_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00047.html#ga671085eed0374e88951b853f9eb027c1">brawcap_handle_t</a> *const&#160;</td>
          <td class="paramname"><em>pHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00050.html#ga98151584e36542e2e1f0defff54cb4f9">brawcap_timestamp_mode_t</a> *const&#160;</td>
          <td class="paramname"><em>pMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="a00035.html">brawcap.h</a>&gt;</code></p>

<p>Reads out the currently configured transmit time stamping mode for the specified handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pHandle</td><td>bRAWcap handle to read from.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pMode</td><td>Will contain the currently used transmit time stamping mode, afterwards.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Status   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="a00048.html#gga9c7e2713c1673acb5aab7c2d06ff481fa200dd935b65622249463189f7a6caf32">BRAWCAP_STATUS_SUCCESS</a>   </td><td class="markdownTableBodyNone">Success.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="a00048.html#gga9c7e2713c1673acb5aab7c2d06ff481fa67cb41d5c4f828e746e586da186436ce">BRAWCAP_STATUS_ERROR_INVALID_POINTER</a>   </td><td class="markdownTableBodyNone">At least one of the given pointer parameters was invalid.   </td></tr>
</table>
</dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<!-- BEGIN BPLUS MODIFICATIONS -->
<!-- Keep the footer clear (removes the default doxygen footer) -->
<!-- END BPLUS MODIFICATIONS -->
</body>
</html>
