<!-- HTML header for doxygen 1.9.5-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>bRAWcap: Receive</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="1_doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="2_bplus_generic_extensions.css" rel="stylesheet" type="text/css"/>
<!-- BEGIN BPLUS MODIFICATIONS -->
<!-- Load and initialize used doxygen extensions -->
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeParagraphLink.init()
</script>
<!-- We use a sticky navigation header - therefore we have to handle the header offset while scrolling and linking -->
<script type="text/javascript">
    // Fix offset due to sticky top (navigation)
    function UpdateHeaderOffset(){
      var headerEl = document.getElementById("top");
      var headerHeight = +headerEl.offsetHeight;
      document.documentElement.style.scrollPaddingTop = headerHeight + 'px';
    }
    // Fix offset and scroll to anchor if page is loaded with anchor url.
    function ScrollToAnchorOnLoad(){
      UpdateHeaderOffset();
      var anchor = document.getElementById(window.location.hash.substr(1))
      if(anchor){
        anchor.scrollIntoView();
      }
    }
    // Add listeners for updating our sticky header offset...
    document.addEventListener('DOMNodeInserted', ScrollToAnchorOnLoad);
    window.addEventListener('resize', UpdateHeaderOffset);
</script>
<!-- END BPLUS MODIFICATIONS -->
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="bplus_logo.svg"/></td>
  <td id="projectalign">
   <div id="projectname">bRAWcap<span id="projectnumber">&#160;1.0.0</span>
   </div>
   <div id="projectbrief">b-plus Technologies - Ethernet Performance Transmitter Receiver</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Receive</div></div>
</div><!--header-->
<div class="contents">

<p>Types and functions for bRAWcap receiving.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="groups" name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__brawcap__filter"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__brawcap__filter.html">Receive Filter</a></td></tr>
<tr class="memdesc:group__brawcap__filter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Types and functions for operating with bRAWcap receive filters. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga72ee682689c05040c162d674238aeb02"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__brawcap__receive.html#ga72ee682689c05040c162d674238aeb02">BRAWCAP_RX_COPY_PACKETS_DEFAULT</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ga72ee682689c05040c162d674238aeb02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default minimum packets to copy value which has to be received before any receive function return even if configured timeout exceeds.  <br /></td></tr>
<tr class="separator:ga72ee682689c05040c162d674238aeb02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4788e60f3255029234090351bd4b9ea9"><td class="memItemLeft" align="right" valign="top"><a id="ga4788e60f3255029234090351bd4b9ea9" name="ga4788e60f3255029234090351bd4b9ea9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BRAWCAP_RX_TIMEOUT_MS_DEFAULT</b>&#160;&#160;&#160;10</td></tr>
<tr class="memdesc:ga4788e60f3255029234090351bd4b9ea9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default timeout in milliseconds after which a bRAWcap receive returns, even if buffer is not yet full but the configured receive min packets to copy must be reached. <br /></td></tr>
<tr class="separator:ga4788e60f3255029234090351bd4b9ea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae657aaeaec025fb03505569ebe24c033"><td class="memItemLeft" align="right" valign="top"><a id="gae657aaeaec025fb03505569ebe24c033" name="gae657aaeaec025fb03505569ebe24c033"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BRAWCAP_RX_TIMESTAMP_MODE_DEFAULT</b>&#160;&#160;&#160;<a class="el" href="group__brawcap__timestamp.html#gga98151584e36542e2e1f0defff54cb4f9aca0e25d4f3a294f2f9f558a0a68e8da5">BRAWCAP_TIMESTAMP_MODE_SYSTEM_LOWPREC</a></td></tr>
<tr class="memdesc:gae657aaeaec025fb03505569ebe24c033"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default receive timestamp mode which will be used. <br /></td></tr>
<tr class="separator:gae657aaeaec025fb03505569ebe24c033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d9da3bd7ced441cbf04f9b911c13a93"><td class="memItemLeft" align="right" valign="top"><a id="ga7d9da3bd7ced441cbf04f9b911c13a93" name="ga7d9da3bd7ced441cbf04f9b911c13a93"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BRAWCAP_RX_VLAN_TAGGING_DEFAULT</b>&#160;&#160;&#160;FALSE</td></tr>
<tr class="memdesc:ga7d9da3bd7ced441cbf04f9b911c13a93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default VLAN tagging mode which will be used. <br /></td></tr>
<tr class="separator:ga7d9da3bd7ced441cbf04f9b911c13a93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga752565ca529d2a78f19396e4e92e2e03"><td class="memItemLeft" align="right" valign="top"><a id="ga752565ca529d2a78f19396e4e92e2e03" name="ga752565ca529d2a78f19396e4e92e2e03"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BRAWCAP_RX_DRIVER_QUEUE_SIZE_DEFAULT</b>&#160;&#160;&#160;4096</td></tr>
<tr class="memdesc:ga752565ca529d2a78f19396e4e92e2e03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default size for driver receive queues in number of packets. <br /></td></tr>
<tr class="separator:ga752565ca529d2a78f19396e4e92e2e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb54bac4f649ab4eabbd68ccadda344d"><td class="memItemLeft" align="right" valign="top"><a id="gadb54bac4f649ab4eabbd68ccadda344d" name="gadb54bac4f649ab4eabbd68ccadda344d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BRAWCAP_RX_TIMEOUT_MS_MAX</b>&#160;&#160;&#160;5000</td></tr>
<tr class="memdesc:gadb54bac4f649ab4eabbd68ccadda344d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum supported receive timeout in number of milliseconds. <br /></td></tr>
<tr class="separator:gadb54bac4f649ab4eabbd68ccadda344d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac4188f1788c6e9489ba67685e89812d"><td class="memItemLeft" align="right" valign="top"><a id="gaac4188f1788c6e9489ba67685e89812d" name="gaac4188f1788c6e9489ba67685e89812d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BRAWCAP_RX_DRIVER_QUEUE_SIZE_MAX</b>&#160;&#160;&#160;40000</td></tr>
<tr class="memdesc:gaac4188f1788c6e9489ba67685e89812d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum size (in number of packets) supported for driver receive queues. <br /></td></tr>
<tr class="separator:gaac4188f1788c6e9489ba67685e89812d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88722606cb9a4cb628db525482395ee3"><td class="memItemLeft" align="right" valign="top"><a id="ga88722606cb9a4cb628db525482395ee3" name="ga88722606cb9a4cb628db525482395ee3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BRAWCAP_RX_DIRECTION_DEFAULT</b>&#160;&#160;&#160;<a class="el" href="group__brawcap__receive.html#ggaf535438d62a0685378b5da61af35a3d9ae00b6187141913c18746b789cff375ea">BRAWCAP_RX_DIRECTION_BOTH</a></td></tr>
<tr class="memdesc:ga88722606cb9a4cb628db525482395ee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default receive direction which will be used. <br /></td></tr>
<tr class="separator:ga88722606cb9a4cb628db525482395ee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5791bfef9bbb31dab119907bf1fb261"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__brawcap__receive.html#gab5791bfef9bbb31dab119907bf1fb261">BRAWCAP_RX_BUFFERS_PER_HANDLE_MAX</a>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:gab5791bfef9bbb31dab119907bf1fb261"><td class="mdescLeft">&#160;</td><td class="mdescRight">Max number of supported packet (receive) buffers per bRAWcap handle.  <br /></td></tr>
<tr class="separator:gab5791bfef9bbb31dab119907bf1fb261"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaed97945884371959a33e46daa7c7181b"><td class="memItemLeft" align="right" valign="top">typedef UINT16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__brawcap__receive.html#gaed97945884371959a33e46daa7c7181b">brawcap_rx_timeout_t</a></td></tr>
<tr class="memdesc:gaed97945884371959a33e46daa7c7181b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for handling receive timeouts in number of milliseconds. The timeout specifies the maximum blocking time in milliseconds for pending bRAWcap receives. If a packet is received or the receive buffer is full before the timeout is reached, receive will return earlier.  <br /></td></tr>
<tr class="separator:gaed97945884371959a33e46daa7c7181b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac71dec73f7c59bc09a291dd02b27310e"><td class="memItemLeft" align="right" valign="top">typedef UINT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__brawcap__receive.html#gac71dec73f7c59bc09a291dd02b27310e">brawcap_rx_min_packets_t</a></td></tr>
<tr class="memdesc:gac71dec73f7c59bc09a291dd02b27310e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for handling the minimum amount of packets to copy before a bRAWcap receive will return. It specifies how many packets should be received before a pending receive returns. Reading more packets in a single call can improve the performance but leads to higher latency.  <br /></td></tr>
<tr class="separator:gac71dec73f7c59bc09a291dd02b27310e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefd27112d47a123ea59b07f1ed1dfefc"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__brawcap__receive.html#gaefd27112d47a123ea59b07f1ed1dfefc">brawcap_rx_callback_t</a>) (<a class="el" href="group__brawcap__generics.html#ga671085eed0374e88951b853f9eb027c1">brawcap_handle_t</a> *const pHandle, const <a class="el" href="group__brawcap__status.html#ga9c7e2713c1673acb5aab7c2d06ff481f">brawcap_status_t</a> status, <a class="el" href="group__brawcap__buffer.html#ga0b3e0af30a05c842f801a981ffd19582">brawcap_buffer_t</a> *const pBuffer, void *pUser)</td></tr>
<tr class="memdesc:gaefd27112d47a123ea59b07f1ed1dfefc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive callback which is called each time a receive has finished. Receiving can be started with <a class="el" href="group__brawcap__receive.html#ga3754d5c0d8f4450c75b835c859393ee4">brawcap_rx_start</a> and has to be stopped with <a class="el" href="group__brawcap__receive.html#ga843f6d93dd1634d3059f967f3c219c6a">brawcap_rx_stop</a>. Before anything can be received it is necessary to attach packet buffers to the bRAWcap handle. This can be done by creating new bRAWcap buffers (<a class="el" href="group__brawcap__buffer.html#gad26a018bb4c368265d829e0f9532f301">brawcap_buffer_create</a>) and attach it with <a class="el" href="group__brawcap__receive.html#gaa94f01c13b4fd705bb6c76fc8422d118">brawcap_rx_buffer_attach</a>.  <br /></td></tr>
<tr class="separator:gaefd27112d47a123ea59b07f1ed1dfefc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gab2d5ed0887223534aa1a7b61b6aebb23"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__brawcap__receive.html#gab2d5ed0887223534aa1a7b61b6aebb23">brawcap_rx_mode_t</a> { <br />
&#160;&#160;<a class="el" href="group__brawcap__receive.html#ggab2d5ed0887223534aa1a7b61b6aebb23ae710c8fce93759cd018dbb2faf3b57c0">BRAWCAP_RX_MODE_LIVE</a> = 1
, <br />
&#160;&#160;<a class="el" href="group__brawcap__receive.html#ggab2d5ed0887223534aa1a7b61b6aebb23af838742512f3abb7d776d983fe4a582a">BRAWCAP_RX_MODE_DUMP</a> = 2
<br />
 }</td></tr>
<tr class="memdesc:gab2d5ed0887223534aa1a7b61b6aebb23"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of receive modes.  <a href="group__brawcap__receive.html#gab2d5ed0887223534aa1a7b61b6aebb23">More...</a><br /></td></tr>
<tr class="separator:gab2d5ed0887223534aa1a7b61b6aebb23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf535438d62a0685378b5da61af35a3d9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__brawcap__receive.html#gaf535438d62a0685378b5da61af35a3d9">brawcap_rx_direction_t</a> { <br />
&#160;&#160;<a class="el" href="group__brawcap__receive.html#ggaf535438d62a0685378b5da61af35a3d9a380d9e7ce5d8288cf928f308b2991570">BRAWCAP_RX_DIRECTION_UNKNOWN</a> = 0x00
, <br />
&#160;&#160;<a class="el" href="group__brawcap__receive.html#ggaf535438d62a0685378b5da61af35a3d9a73d2c6837bf71a6edf384212e04880d7">BRAWCAP_RX_DIRECTION_IN</a> = 0x01
, <br />
&#160;&#160;<a class="el" href="group__brawcap__receive.html#ggaf535438d62a0685378b5da61af35a3d9ab06dbb4df86375e190a68d8c1c9ea5af">BRAWCAP_RX_DIRECTION_OUT</a> = 0x02
, <br />
&#160;&#160;<a class="el" href="group__brawcap__receive.html#ggaf535438d62a0685378b5da61af35a3d9ae00b6187141913c18746b789cff375ea">BRAWCAP_RX_DIRECTION_BOTH</a> = 0x03
<br />
 }</td></tr>
<tr class="memdesc:gaf535438d62a0685378b5da61af35a3d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of supported receive directions.  <a href="group__brawcap__receive.html#gaf535438d62a0685378b5da61af35a3d9">More...</a><br /></td></tr>
<tr class="separator:gaf535438d62a0685378b5da61af35a3d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga132d297049ed7ee337acb28f27349e44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__brawcap__status.html#ga9c7e2713c1673acb5aab7c2d06ff481f">brawcap_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__brawcap__receive.html#ga132d297049ed7ee337acb28f27349e44">brawcap_rx_packet</a> (<a class="el" href="group__brawcap__generics.html#ga671085eed0374e88951b853f9eb027c1">brawcap_handle_t</a> *const pHandle, <a class="el" href="group__brawcap__packet.html#ga840aa22feee3a992bafe63f3653afbf7">brawcap_packet_t</a> *const pPacket)</td></tr>
<tr class="memdesc:ga132d297049ed7ee337acb28f27349e44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives a single packet from the specified handle.  <br /></td></tr>
<tr class="separator:ga132d297049ed7ee337acb28f27349e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3754d5c0d8f4450c75b835c859393ee4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__brawcap__status.html#ga9c7e2713c1673acb5aab7c2d06ff481f">brawcap_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__brawcap__receive.html#ga3754d5c0d8f4450c75b835c859393ee4">brawcap_rx_start</a> (<a class="el" href="group__brawcap__generics.html#ga671085eed0374e88951b853f9eb027c1">brawcap_handle_t</a> *const pHandle, <a class="el" href="group__brawcap__receive.html#gaefd27112d47a123ea59b07f1ed1dfefc">brawcap_rx_callback_t</a> const callback, void *const pUser, const BOOLEAN indicateNoPackets)</td></tr>
<tr class="memdesc:ga3754d5c0d8f4450c75b835c859393ee4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts the internal receive loop.  <br /></td></tr>
<tr class="separator:ga3754d5c0d8f4450c75b835c859393ee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga843f6d93dd1634d3059f967f3c219c6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__brawcap__status.html#ga9c7e2713c1673acb5aab7c2d06ff481f">brawcap_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__brawcap__receive.html#ga843f6d93dd1634d3059f967f3c219c6a">brawcap_rx_stop</a> (<a class="el" href="group__brawcap__generics.html#ga671085eed0374e88951b853f9eb027c1">brawcap_handle_t</a> *const pHandle)</td></tr>
<tr class="memdesc:ga843f6d93dd1634d3059f967f3c219c6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops the internal receive loop.  <br /></td></tr>
<tr class="separator:ga843f6d93dd1634d3059f967f3c219c6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa94f01c13b4fd705bb6c76fc8422d118"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__brawcap__status.html#ga9c7e2713c1673acb5aab7c2d06ff481f">brawcap_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__brawcap__receive.html#gaa94f01c13b4fd705bb6c76fc8422d118">brawcap_rx_buffer_attach</a> (<a class="el" href="group__brawcap__generics.html#ga671085eed0374e88951b853f9eb027c1">brawcap_handle_t</a> *const pHandle, <a class="el" href="group__brawcap__buffer.html#ga0b3e0af30a05c842f801a981ffd19582">brawcap_buffer_t</a> *const pBuffer)</td></tr>
<tr class="memdesc:gaa94f01c13b4fd705bb6c76fc8422d118"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attaches the specified bRAWcap packet buffer to the specified handle.  <br /></td></tr>
<tr class="separator:gaa94f01c13b4fd705bb6c76fc8422d118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fa3adba907d4f96c29a752656029151"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__brawcap__status.html#ga9c7e2713c1673acb5aab7c2d06ff481f">brawcap_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__brawcap__receive.html#ga2fa3adba907d4f96c29a752656029151">brawcap_rx_buffer_detach</a> (<a class="el" href="group__brawcap__generics.html#ga671085eed0374e88951b853f9eb027c1">brawcap_handle_t</a> *const pHandle, <a class="el" href="group__brawcap__buffer.html#ga0b3e0af30a05c842f801a981ffd19582">brawcap_buffer_t</a> *const pBuffer)</td></tr>
<tr class="memdesc:ga2fa3adba907d4f96c29a752656029151"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detaches the specified bRAWcap packet buffer from the specified handle.  <br /></td></tr>
<tr class="separator:ga2fa3adba907d4f96c29a752656029151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7eb9a5a77e7e0bdf07b863d870f7a2b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__brawcap__status.html#ga9c7e2713c1673acb5aab7c2d06ff481f">brawcap_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__brawcap__receive.html#ga7eb9a5a77e7e0bdf07b863d870f7a2b9">brawcap_rx_direction_set</a> (<a class="el" href="group__brawcap__generics.html#ga671085eed0374e88951b853f9eb027c1">brawcap_handle_t</a> *const pHandle, const <a class="el" href="group__brawcap__receive.html#gaf535438d62a0685378b5da61af35a3d9">brawcap_rx_direction_t</a> direction)</td></tr>
<tr class="memdesc:ga7eb9a5a77e7e0bdf07b863d870f7a2b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the receive direction for the specified handle.  <br /></td></tr>
<tr class="separator:ga7eb9a5a77e7e0bdf07b863d870f7a2b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ffedb21061d52bf98bc4a9ff3b52d82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__brawcap__status.html#ga9c7e2713c1673acb5aab7c2d06ff481f">brawcap_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__brawcap__receive.html#ga1ffedb21061d52bf98bc4a9ff3b52d82">brawcap_rx_direction_get</a> (<a class="el" href="group__brawcap__generics.html#ga671085eed0374e88951b853f9eb027c1">brawcap_handle_t</a> *const pHandle, <a class="el" href="group__brawcap__receive.html#gaf535438d62a0685378b5da61af35a3d9">brawcap_rx_direction_t</a> *const pDirection)</td></tr>
<tr class="memdesc:ga1ffedb21061d52bf98bc4a9ff3b52d82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads out the currently configured receive direction of the specified handle.  <br /></td></tr>
<tr class="separator:ga1ffedb21061d52bf98bc4a9ff3b52d82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga097337afa32a171a7d17b267d2aafebc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__brawcap__status.html#ga9c7e2713c1673acb5aab7c2d06ff481f">brawcap_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__brawcap__receive.html#ga097337afa32a171a7d17b267d2aafebc">brawcap_rx_min_packets_set</a> (<a class="el" href="group__brawcap__generics.html#ga671085eed0374e88951b853f9eb027c1">brawcap_handle_t</a> *const pHandle, const <a class="el" href="group__brawcap__receive.html#gac71dec73f7c59bc09a291dd02b27310e">brawcap_rx_min_packets_t</a> minPackets)</td></tr>
<tr class="memdesc:ga097337afa32a171a7d17b267d2aafebc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the minimum amount of packets to receive for the specified handle.  <br /></td></tr>
<tr class="separator:ga097337afa32a171a7d17b267d2aafebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac44d8a782c2001ee540dad4c45373cab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__brawcap__status.html#ga9c7e2713c1673acb5aab7c2d06ff481f">brawcap_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__brawcap__receive.html#gac44d8a782c2001ee540dad4c45373cab">brawcap_rx_min_packets_get</a> (<a class="el" href="group__brawcap__generics.html#ga671085eed0374e88951b853f9eb027c1">brawcap_handle_t</a> *const pHandle, <a class="el" href="group__brawcap__receive.html#gac71dec73f7c59bc09a291dd02b27310e">brawcap_rx_min_packets_t</a> *const pMinPackets)</td></tr>
<tr class="memdesc:gac44d8a782c2001ee540dad4c45373cab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads out the currently configured number of packets to receive for the specified handle.  <br /></td></tr>
<tr class="separator:gac44d8a782c2001ee540dad4c45373cab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a7ccf66c3a4672304e6ea32e9da0e4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__brawcap__status.html#ga9c7e2713c1673acb5aab7c2d06ff481f">brawcap_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__brawcap__receive.html#ga5a7ccf66c3a4672304e6ea32e9da0e4f">brawcap_rx_timeout_set</a> (<a class="el" href="group__brawcap__generics.html#ga671085eed0374e88951b853f9eb027c1">brawcap_handle_t</a> *const pHandle, const <a class="el" href="group__brawcap__receive.html#gaed97945884371959a33e46daa7c7181b">brawcap_rx_timeout_t</a> timeout_ms)</td></tr>
<tr class="memdesc:ga5a7ccf66c3a4672304e6ea32e9da0e4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the receive timeout for the specified handle.  <br /></td></tr>
<tr class="separator:ga5a7ccf66c3a4672304e6ea32e9da0e4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33f42d5a8d31fc0ba7c515646c6c0663"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__brawcap__status.html#ga9c7e2713c1673acb5aab7c2d06ff481f">brawcap_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__brawcap__receive.html#ga33f42d5a8d31fc0ba7c515646c6c0663">brawcap_rx_timeout_get</a> (<a class="el" href="group__brawcap__generics.html#ga671085eed0374e88951b853f9eb027c1">brawcap_handle_t</a> *const pHandle, <a class="el" href="group__brawcap__receive.html#gaed97945884371959a33e46daa7c7181b">brawcap_rx_timeout_t</a> *const pTimeout_ms)</td></tr>
<tr class="memdesc:ga33f42d5a8d31fc0ba7c515646c6c0663"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads out the currently configured receive timeout for the specified handle.  <br /></td></tr>
<tr class="separator:ga33f42d5a8d31fc0ba7c515646c6c0663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac08bee873c62ebb138797c12e52bebb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__brawcap__status.html#ga9c7e2713c1673acb5aab7c2d06ff481f">brawcap_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__brawcap__receive.html#gaac08bee873c62ebb138797c12e52bebb">brawcap_rx_filter_set</a> (<a class="el" href="group__brawcap__generics.html#ga671085eed0374e88951b853f9eb027c1">brawcap_handle_t</a> *const pHandle, const <a class="el" href="group__brawcap__filter.html#ga4225c6360a481d7051e5d81045eb8d22">brawcap_filter_t</a> *const pFilter)</td></tr>
<tr class="memdesc:gaac08bee873c62ebb138797c12e52bebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the specified filter to the specified handle.  <br /></td></tr>
<tr class="separator:gaac08bee873c62ebb138797c12e52bebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc92c0d0fe9e2ba5719798c9fdbd9d16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__brawcap__status.html#ga9c7e2713c1673acb5aab7c2d06ff481f">brawcap_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__brawcap__receive.html#gacc92c0d0fe9e2ba5719798c9fdbd9d16">brawcap_rx_filter_get</a> (<a class="el" href="group__brawcap__generics.html#ga671085eed0374e88951b853f9eb027c1">brawcap_handle_t</a> *const pHandle, <a class="el" href="group__brawcap__filter.html#ga4225c6360a481d7051e5d81045eb8d22">brawcap_filter_t</a> *const pFilter)</td></tr>
<tr class="memdesc:gacc92c0d0fe9e2ba5719798c9fdbd9d16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads out the currently configured filter for the specified handle.  <br /></td></tr>
<tr class="separator:gacc92c0d0fe9e2ba5719798c9fdbd9d16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8048f83ce46971a2b16e20ec7f08c4c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__brawcap__status.html#ga9c7e2713c1673acb5aab7c2d06ff481f">brawcap_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__brawcap__receive.html#ga8048f83ce46971a2b16e20ec7f08c4c6">brawcap_rx_promiscuous_mode_set</a> (<a class="el" href="group__brawcap__generics.html#ga671085eed0374e88951b853f9eb027c1">brawcap_handle_t</a> *const pHandle, const BOOLEAN enable)</td></tr>
<tr class="memdesc:ga8048f83ce46971a2b16e20ec7f08c4c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the current promiscuous mode flag for the specified handle.  <br /></td></tr>
<tr class="separator:ga8048f83ce46971a2b16e20ec7f08c4c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93e4c6389eea2a8f516fc6e6f86fc2ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__brawcap__status.html#ga9c7e2713c1673acb5aab7c2d06ff481f">brawcap_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__brawcap__receive.html#ga93e4c6389eea2a8f516fc6e6f86fc2ae">brawcap_rx_promiscuous_mode_get</a> (<a class="el" href="group__brawcap__generics.html#ga671085eed0374e88951b853f9eb027c1">brawcap_handle_t</a> *const pHandle, BOOLEAN *const pEnabled, BOOLEAN *const pEnabledAdapter)</td></tr>
<tr class="memdesc:ga93e4c6389eea2a8f516fc6e6f86fc2ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads out the current promiscuous mode state for the specified handle.  <br /></td></tr>
<tr class="separator:ga93e4c6389eea2a8f516fc6e6f86fc2ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79d75083f93e69a323afc78668ffd38c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__brawcap__status.html#ga9c7e2713c1673acb5aab7c2d06ff481f">brawcap_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__brawcap__receive.html#ga79d75083f93e69a323afc78668ffd38c">brawcap_rx_timestamp_capabilities</a> (<a class="el" href="group__brawcap__generics.html#ga671085eed0374e88951b853f9eb027c1">brawcap_handle_t</a> *const pHandle, <a class="el" href="group__brawcap__timestamp.html#ga2e576ed8155bf55660489ea9406a69d5">brawcap_timestamp_capabilities_t</a> *const pCapabilities)</td></tr>
<tr class="memdesc:ga79d75083f93e69a323afc78668ffd38c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads out the available receive timestamp modes for the specified handle.  <br /></td></tr>
<tr class="separator:ga79d75083f93e69a323afc78668ffd38c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae642dce7272a00c24a539f7e605c98d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__brawcap__status.html#ga9c7e2713c1673acb5aab7c2d06ff481f">brawcap_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__brawcap__receive.html#gae642dce7272a00c24a539f7e605c98d6">brawcap_rx_timestamp_mode_get</a> (<a class="el" href="group__brawcap__generics.html#ga671085eed0374e88951b853f9eb027c1">brawcap_handle_t</a> *const pHandle, <a class="el" href="group__brawcap__timestamp.html#ga98151584e36542e2e1f0defff54cb4f9">brawcap_timestamp_mode_t</a> *const pMode)</td></tr>
<tr class="memdesc:gae642dce7272a00c24a539f7e605c98d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads out the currently configured receive time stamping mode for the specified handle.  <br /></td></tr>
<tr class="separator:gae642dce7272a00c24a539f7e605c98d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1d6bed398e0b10376cc0e93528cfe5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__brawcap__status.html#ga9c7e2713c1673acb5aab7c2d06ff481f">brawcap_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__brawcap__receive.html#gaa1d6bed398e0b10376cc0e93528cfe5f">brawcap_rx_timestamp_mode_set</a> (<a class="el" href="group__brawcap__generics.html#ga671085eed0374e88951b853f9eb027c1">brawcap_handle_t</a> *const pHandle, const <a class="el" href="group__brawcap__timestamp.html#ga98151584e36542e2e1f0defff54cb4f9">brawcap_timestamp_mode_t</a> mode)</td></tr>
<tr class="memdesc:gaa1d6bed398e0b10376cc0e93528cfe5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the used receive time stamping mode for the specified handle.  <br /></td></tr>
<tr class="separator:gaa1d6bed398e0b10376cc0e93528cfe5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70847c908de1210faab988a1f2ca0ccf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__brawcap__status.html#ga9c7e2713c1673acb5aab7c2d06ff481f">brawcap_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__brawcap__receive.html#ga70847c908de1210faab988a1f2ca0ccf">brawcap_rx_vlan_tagging_set</a> (<a class="el" href="group__brawcap__generics.html#ga671085eed0374e88951b853f9eb027c1">brawcap_handle_t</a> *const pHandle, const BOOLEAN enable)</td></tr>
<tr class="memdesc:ga70847c908de1210faab988a1f2ca0ccf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the current VLAN tagging flag for the specified handle.  <br /></td></tr>
<tr class="separator:ga70847c908de1210faab988a1f2ca0ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga511ecf7d0d33d9df949aeee86ab0238a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__brawcap__status.html#ga9c7e2713c1673acb5aab7c2d06ff481f">brawcap_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__brawcap__receive.html#ga511ecf7d0d33d9df949aeee86ab0238a">brawcap_rx_vlan_tagging_get</a> (<a class="el" href="group__brawcap__generics.html#ga671085eed0374e88951b853f9eb027c1">brawcap_handle_t</a> *const pHandle, BOOLEAN *const pEnabled)</td></tr>
<tr class="memdesc:ga511ecf7d0d33d9df949aeee86ab0238a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads out the configured VLAN tagging state for the specified handle.  <br /></td></tr>
<tr class="separator:ga511ecf7d0d33d9df949aeee86ab0238a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga519867331e1b09e42706793fe2b76b9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__brawcap__status.html#ga9c7e2713c1673acb5aab7c2d06ff481f">brawcap_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__brawcap__receive.html#ga519867331e1b09e42706793fe2b76b9b">brawcap_rx_driver_queue_size_set</a> (<a class="el" href="group__brawcap__generics.html#ga671085eed0374e88951b853f9eb027c1">brawcap_handle_t</a> *const pHandle, const <a class="el" href="group__brawcap__generics.html#ga5333ed197831fcb54dc690a993eb7310">brawcap_queue_size_t</a> size)</td></tr>
<tr class="memdesc:ga519867331e1b09e42706793fe2b76b9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the driver queue size (in number of packets) for the specified handle.  <br /></td></tr>
<tr class="separator:ga519867331e1b09e42706793fe2b76b9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9fe06bea62401c32e686775e6d093874"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__brawcap__status.html#ga9c7e2713c1673acb5aab7c2d06ff481f">brawcap_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__brawcap__receive.html#ga9fe06bea62401c32e686775e6d093874">brawcap_rx_driver_queue_size_get</a> (<a class="el" href="group__brawcap__generics.html#ga671085eed0374e88951b853f9eb027c1">brawcap_handle_t</a> *const pHandle, <a class="el" href="group__brawcap__generics.html#ga5333ed197831fcb54dc690a993eb7310">brawcap_queue_size_t</a> *const pSize)</td></tr>
<tr class="memdesc:ga9fe06bea62401c32e686775e6d093874"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads out the currently configured driver receive queue size for the specified handle.  <br /></td></tr>
<tr class="separator:ga9fe06bea62401c32e686775e6d093874"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Types and functions for bRAWcap receiving. </p>
<p>List of examples:</p><ol type="1">
<li><a class="el" href="05_receive_simple_packet_receiver_8c-example.html">Simple Packet Receiver</a></li>
<li><a class="el" href="07_receive_buffered_receiver_8c-example.html">Buffered Receiver</a></li>
<li><a class="el" href="08_receive_timestamp_inspector_8c-example.html">Timestamp Inspector</a> </li>
</ol>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga72ee682689c05040c162d674238aeb02" name="ga72ee682689c05040c162d674238aeb02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga72ee682689c05040c162d674238aeb02">&#9670;&#160;</a></span>BRAWCAP_RX_COPY_PACKETS_DEFAULT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BRAWCAP_RX_COPY_PACKETS_DEFAULT&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="brawcap__types__shared_8h.html">brawcap_types_shared.h</a>&gt;</code></p>

<p>Default minimum packets to copy value which has to be received before any receive function return even if configured timeout exceeds. </p>
<dl class="section note"><dt>Note</dt><dd>bRAWcap waits at least up to 10 times the configured timeout before finally returning if the minimum number of packets has not yet been received.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If a timeout of zero which is equivalent to infinite wait is configured it blocks until the minimum amount of packets are received and will not return earlier. </dd></dl>

</div>
</div>
<a id="gab5791bfef9bbb31dab119907bf1fb261" name="gab5791bfef9bbb31dab119907bf1fb261"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5791bfef9bbb31dab119907bf1fb261">&#9670;&#160;</a></span>BRAWCAP_RX_BUFFERS_PER_HANDLE_MAX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BRAWCAP_RX_BUFFERS_PER_HANDLE_MAX&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="brawcap__types__um_8h.html">brawcap_types_um.h</a>&gt;</code></p>

<p>Max number of supported packet (receive) buffers per bRAWcap handle. </p>
<p>Limits the number of buffers which can be attached to a single handle with <a class="el" href="group__brawcap__receive.html#gaa94f01c13b4fd705bb6c76fc8422d118">brawcap_rx_buffer_attach</a>. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gaed97945884371959a33e46daa7c7181b" name="gaed97945884371959a33e46daa7c7181b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed97945884371959a33e46daa7c7181b">&#9670;&#160;</a></span>brawcap_rx_timeout_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef UINT16 <a class="el" href="group__brawcap__receive.html#gaed97945884371959a33e46daa7c7181b">brawcap_rx_timeout_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="brawcap__types__shared_8h.html">brawcap_types_shared.h</a>&gt;</code></p>

<p>Type for handling receive timeouts in number of milliseconds. The timeout specifies the maximum blocking time in milliseconds for pending bRAWcap receives. If a packet is received or the receive buffer is full before the timeout is reached, receive will return earlier. </p>
<dl class="section attention"><dt>Attention</dt><dd>A receive timeout value of zero corresponds to an infinite wait. This means that bRAWcap receive will only return if<ul>
<li><a class="el" href="group__brawcap__receive.html#ga132d297049ed7ee337acb28f27349e44">brawcap_rx_packet</a> - a packet is received,</li>
<li><a class="el" href="group__brawcap__receive.html#ga3754d5c0d8f4450c75b835c859393ee4">brawcap_rx_start</a> - the minimum amount of packets to copy is reached (see <a class="el" href="group__brawcap__receive.html#gac71dec73f7c59bc09a291dd02b27310e">brawcap_rx_min_packets_t</a>) or the attached buffer is full - whichever comes first. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gac71dec73f7c59bc09a291dd02b27310e" name="gac71dec73f7c59bc09a291dd02b27310e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac71dec73f7c59bc09a291dd02b27310e">&#9670;&#160;</a></span>brawcap_rx_min_packets_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef UINT32 <a class="el" href="group__brawcap__receive.html#gac71dec73f7c59bc09a291dd02b27310e">brawcap_rx_min_packets_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="brawcap__types__shared_8h.html">brawcap_types_shared.h</a>&gt;</code></p>

<p>Type for handling the minimum amount of packets to copy before a bRAWcap receive will return. It specifies how many packets should be received before a pending receive returns. Reading more packets in a single call can improve the performance but leads to higher latency. </p>
<dl class="section note"><dt>Note</dt><dd>This setting is only used with looped receive (<a class="el" href="group__brawcap__receive.html#ga3754d5c0d8f4450c75b835c859393ee4">brawcap_rx_start</a>) and has no impact on single packet reception (<a class="el" href="group__brawcap__receive.html#ga132d297049ed7ee337acb28f27349e44">brawcap_rx_packet</a>). </dd></dl>

</div>
</div>
<a id="gaefd27112d47a123ea59b07f1ed1dfefc" name="gaefd27112d47a123ea59b07f1ed1dfefc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaefd27112d47a123ea59b07f1ed1dfefc">&#9670;&#160;</a></span>brawcap_rx_callback_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* brawcap_rx_callback_t) (<a class="el" href="group__brawcap__generics.html#ga671085eed0374e88951b853f9eb027c1">brawcap_handle_t</a> *const pHandle, const <a class="el" href="group__brawcap__status.html#ga9c7e2713c1673acb5aab7c2d06ff481f">brawcap_status_t</a> status, <a class="el" href="group__brawcap__buffer.html#ga0b3e0af30a05c842f801a981ffd19582">brawcap_buffer_t</a> *const pBuffer, void *pUser)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="brawcap__types__um_8h.html">brawcap_types_um.h</a>&gt;</code></p>

<p>Receive callback which is called each time a receive has finished. Receiving can be started with <a class="el" href="group__brawcap__receive.html#ga3754d5c0d8f4450c75b835c859393ee4">brawcap_rx_start</a> and has to be stopped with <a class="el" href="group__brawcap__receive.html#ga843f6d93dd1634d3059f967f3c219c6a">brawcap_rx_stop</a>. Before anything can be received it is necessary to attach packet buffers to the bRAWcap handle. This can be done by creating new bRAWcap buffers (<a class="el" href="group__brawcap__buffer.html#gad26a018bb4c368265d829e0f9532f301">brawcap_buffer_create</a>) and attach it with <a class="el" href="group__brawcap__receive.html#gaa94f01c13b4fd705bb6c76fc8422d118">brawcap_rx_buffer_attach</a>. </p>
<dl class="section note"><dt>Note</dt><dd>If a handle has multiple buffers attached, the callback may be called in parallel (by different threads).</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Executing to long in the callback can lead to a bottleneck in reception! It is recommended that the driver always has at least one (free) buffer were it can store the packets to.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pHandle</td><td>Handle on which the receive returned.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">status</td><td>The overall receive status see <a class="el" href="group__brawcap__status.html#ga9c7e2713c1673acb5aab7c2d06ff481f">brawcap_status_t</a> for possible return values.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pBuffer</td><td>Pointer to the buffer which has finished receiving. It can be used to access all packets in the buffer and allows to retrieve information for each received packet (e.g. payload, length, timestamp, ...).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pUser</td><td>Pointer to a user defined context. It allows access to user specific data within the callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gab2d5ed0887223534aa1a7b61b6aebb23" name="gab2d5ed0887223534aa1a7b61b6aebb23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab2d5ed0887223534aa1a7b61b6aebb23">&#9670;&#160;</a></span>brawcap_rx_mode_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__brawcap__receive.html#gab2d5ed0887223534aa1a7b61b6aebb23">brawcap_rx_mode_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="brawcap__types__shared_8h.html">brawcap_types_shared.h</a>&gt;</code></p>

<p>List of receive modes. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggab2d5ed0887223534aa1a7b61b6aebb23ae710c8fce93759cd018dbb2faf3b57c0" name="ggab2d5ed0887223534aa1a7b61b6aebb23ae710c8fce93759cd018dbb2faf3b57c0"></a>BRAWCAP_RX_MODE_LIVE&#160;</td><td class="fielddoc"><p>Received packets are stored in a user created bRAWcap packet (buffer) and provided to the calling application for processing. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab2d5ed0887223534aa1a7b61b6aebb23af838742512f3abb7d776d983fe4a582a" name="ggab2d5ed0887223534aa1a7b61b6aebb23af838742512f3abb7d776d983fe4a582a"></a>BRAWCAP_RX_MODE_DUMP&#160;</td><td class="fielddoc"><p>Received packets are directly written to disk. </p>
<dl class="section note"><dt>Note</dt><dd>Dumping mode is not yet supported and may be added to later releases. </dd></dl>
</td></tr>
</table>

</div>
</div>
<a id="gaf535438d62a0685378b5da61af35a3d9" name="gaf535438d62a0685378b5da61af35a3d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf535438d62a0685378b5da61af35a3d9">&#9670;&#160;</a></span>brawcap_rx_direction_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__brawcap__receive.html#gaf535438d62a0685378b5da61af35a3d9">brawcap_rx_direction_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="brawcap__types__shared_8h.html">brawcap_types_shared.h</a>&gt;</code></p>

<p>List of supported receive directions. </p>
<p>The receive direction allows the select for which direction (transmit/receive) the packets shall be captured. This setting can be seen as some kind of generic receive filter. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaf535438d62a0685378b5da61af35a3d9a380d9e7ce5d8288cf928f308b2991570" name="ggaf535438d62a0685378b5da61af35a3d9a380d9e7ce5d8288cf928f308b2991570"></a>BRAWCAP_RX_DIRECTION_UNKNOWN&#160;</td><td class="fielddoc"><p>Stops to receive packets of any direction. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf535438d62a0685378b5da61af35a3d9a73d2c6837bf71a6edf384212e04880d7" name="ggaf535438d62a0685378b5da61af35a3d9a73d2c6837bf71a6edf384212e04880d7"></a>BRAWCAP_RX_DIRECTION_IN&#160;</td><td class="fielddoc"><p>Only received packets by the network adapter will be received. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf535438d62a0685378b5da61af35a3d9ab06dbb4df86375e190a68d8c1c9ea5af" name="ggaf535438d62a0685378b5da61af35a3d9ab06dbb4df86375e190a68d8c1c9ea5af"></a>BRAWCAP_RX_DIRECTION_OUT&#160;</td><td class="fielddoc"><p>Only transmitted packets by bRAWcap or upper network stack drivers will be received. This allows some kind of loopback for packets which are transmitted to the network. </p>
<dl class="section note"><dt>Note</dt><dd>This currently does not include packets sent to localhost (IP 127.0.0.1), because they are not transmitted/received via a real network adapter. Instead Windows creates a separate "virtual" adapter for localhost communication. This adapter is currently not supported by bRAWcap. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="ggaf535438d62a0685378b5da61af35a3d9ae00b6187141913c18746b789cff375ea" name="ggaf535438d62a0685378b5da61af35a3d9ae00b6187141913c18746b789cff375ea"></a>BRAWCAP_RX_DIRECTION_BOTH&#160;</td><td class="fielddoc"><p>Both transmitted packets by bRAWcap or upper network stack drivers and received packets from the underlying network adapter will be received. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga132d297049ed7ee337acb28f27349e44" name="ga132d297049ed7ee337acb28f27349e44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga132d297049ed7ee337acb28f27349e44">&#9670;&#160;</a></span>brawcap_rx_packet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__brawcap__status.html#ga9c7e2713c1673acb5aab7c2d06ff481f">brawcap_status_t</a> brawcap_rx_packet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__brawcap__generics.html#ga671085eed0374e88951b853f9eb027c1">brawcap_handle_t</a> *const&#160;</td>
          <td class="paramname"><em>pHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__brawcap__packet.html#ga840aa22feee3a992bafe63f3653afbf7">brawcap_packet_t</a> *const&#160;</td>
          <td class="paramname"><em>pPacket</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="brawcap_8h.html">brawcap.h</a>&gt;</code></p>

<p>Receives a single packet from the specified handle. </p>
<p>The caller must provide a valid packet were bRAWcap will store the received data. To create a packet use <a class="el" href="group__brawcap__packet.html#ga68e198e3b23bb01fe147fa4f29760e03">brawcap_packet_create</a> or use a buffered packet which was returned by a valid buffer with <a class="el" href="group__brawcap__buffer.html#gaa38e70a8fa674eb38ee1480831e438e2">brawcap_buffer_at_index</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Parallel receives per handle are not allowed. This means that if there is any other receive pending on the handle each further initiated receive will fail until the pending operation has finished.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pHandle</td><td>bRAWcap handle to receive from.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pPacket</td><td>Packet were the received data will be stored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Status   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group__brawcap__status.html#gga9c7e2713c1673acb5aab7c2d06ff481fa200dd935b65622249463189f7a6caf32">BRAWCAP_STATUS_SUCCESS</a>   </td><td class="markdownTableBodyNone">Success.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="group__brawcap__status.html#gga9c7e2713c1673acb5aab7c2d06ff481fa67cb41d5c4f828e746e586da186436ce">BRAWCAP_STATUS_ERROR_INVALID_POINTER</a>   </td><td class="markdownTableBodyNone">At least one of the given pointer parameters was invalid.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group__brawcap__status.html#gga9c7e2713c1673acb5aab7c2d06ff481fa7b5947d7cb66cf12afc410f255622eed">BRAWCAP_STATUS_WARNING_PENDING</a>   </td><td class="markdownTableBodyNone">Another receive is still pending/active.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="group__brawcap__status.html#gga9c7e2713c1673acb5aab7c2d06ff481fa1df8bf6b3b7171107e611a28c1148d02">BRAWCAP_STATUS_ERROR_DRIVER_NOT_AVAILABLE</a>   </td><td class="markdownTableBodyNone">bRAWcap driver is not active (anymore) on the adapter.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group__brawcap__status.html#gga9c7e2713c1673acb5aab7c2d06ff481faf67498d12e585323c9dd217f39d0cf46">BRAWCAP_STATUS_WARNING_DEMO_MODE</a>   </td><td class="markdownTableBodyNone">Running in demo mode (no license).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="group__brawcap__status.html#gga9c7e2713c1673acb5aab7c2d06ff481fa318dec04646ebef9e4ec33318790bb17">BRAWCAP_STATUS_ERROR_DRIVER_IO_FAILED</a>   </td><td class="markdownTableBodyNone">Communicating with bRAWcap driver failed.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group__brawcap__status.html#gga9c7e2713c1673acb5aab7c2d06ff481faee6e834dad28c3b87759c17566db025a">BRAWCAP_STATUS_INFO_NO_DATA</a>   </td><td class="markdownTableBodyNone">Returned without any data received (due to timeout).   </td></tr>
</table>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="05_receive_simple_packet_receiver_8c-example.html#a9">05_receive_simple_packet_receiver.c</a>, and <a class="el" href="08_receive_timestamp_inspector_8c-example.html#a18">08_receive_timestamp_inspector.c</a>.</dd>
</dl>

</div>
</div>
<a id="ga3754d5c0d8f4450c75b835c859393ee4" name="ga3754d5c0d8f4450c75b835c859393ee4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3754d5c0d8f4450c75b835c859393ee4">&#9670;&#160;</a></span>brawcap_rx_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__brawcap__status.html#ga9c7e2713c1673acb5aab7c2d06ff481f">brawcap_status_t</a> brawcap_rx_start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__brawcap__generics.html#ga671085eed0374e88951b853f9eb027c1">brawcap_handle_t</a> *const&#160;</td>
          <td class="paramname"><em>pHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__brawcap__receive.html#gaefd27112d47a123ea59b07f1ed1dfefc">brawcap_rx_callback_t</a> const&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>pUser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BOOLEAN&#160;</td>
          <td class="paramname"><em>indicateNoPackets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="brawcap_8h.html">brawcap.h</a>&gt;</code></p>

<p>Starts the internal receive loop. </p>
<p>To receive data using this method it is necessary to attach memory to the bRAWcap handle were received data can be stored. This can be done by attaching (with <a class="el" href="group__brawcap__receive.html#gaa94f01c13b4fd705bb6c76fc8422d118">brawcap_rx_buffer_attach</a>) a previously created bRAWcap packet buffer (with <a class="el" href="group__brawcap__buffer.html#gad26a018bb4c368265d829e0f9532f301">brawcap_buffer_create</a>).</p>
<p>When a reception has finished (due to timeout, min packets or full buffer) the receive callback will be called for this handle (<a class="el" href="group__brawcap__receive.html#gaefd27112d47a123ea59b07f1ed1dfefc">brawcap_rx_callback_t</a>). In this callback the user application can do it´s post processing on the received data. If the user application does not detach the buffer (with <a class="el" href="group__brawcap__receive.html#ga2fa3adba907d4f96c29a752656029151">brawcap_rx_buffer_detach</a>) it will be reused for receiving after callback has completed.</p>
<p>The user application should do it´s post processing anyway, as fast as possible. Depending on the current bandwidth the attached buffers may be filled up very fast. If the user application takes to long it will lead to a bottleneck in the reception and the driver runs out of resources. This may result in performance degradation or packet loss.</p>
<p>It is possible to attach more than only one buffer to a single handle. This ensures that the bRAWcap driver can toggle the buffers during the reception. This reduces the time gap the driver has to buffer data internally (because there is no user buffer available). With more than one buffer the driver can still fill up another buffer while the user application does it´s post processing. Therefore in general, using more than one buffer increases the performance.</p>
<dl class="section note"><dt>Note</dt><dd>Due to the focus on optimized throughput with minimal CPU load bRAWcap does not fill up the packets in the buffer with the same sequence they were received by the adapter. Here we want to give some additional information on the topic of "packet sequence/timestamp":<ul>
<li>First of all it should be known that the receive sequence may not be equal to the sending sequence. Due to several senders or some network managers in between (switches and so on...). For any protocols which require a ordered packet stream, there will be at least one field in the packet payload which allows to sort the packets on the receiver side. This is a "higher" layer topic and not part of bRAWcap.</li>
<li>With the bRAWcap supported timestamp mechanisms it is possible to sort the received packets corresponding to their receive timestamps. But keep in mind that only the <a class="el" href="group__brawcap__timestamp.html#gga98151584e36542e2e1f0defff54cb4f9a6427ebd0d5d30cf8cb9e5780ed9d9ae9">BRAWCAP_TIMESTAMP_MODE_ADAPTER_HARDWARE</a> guarantees that the receive timestamps really match the received packet sequence on the adapter. To use the named timestamp mechanism, the underlying network adapter must support it. Any other timestamp is generated by software. Windows is not a realtime operation system, and therefore due to multithreading, scheduling (...) it could happen that some packets are processed before other packets which was received earlier. Especially the Windows network stack feature called "receive side scaling" can also increase the issue of incorrect packet sequences.</li>
</ul>
</dd></dl>
<dl class="section invariant"><dt>Invariant</dt><dd>The user parameter allows access to user defined context. The given pointer is not used and validated by bRAWcap. Therefore the user is responsible for validating the context in the callback before accessing it.</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>After starting receive <a class="el" href="group__brawcap__receive.html#ga132d297049ed7ee337acb28f27349e44">brawcap_rx_packet</a> can not be used until you stop the receive with <a class="el" href="group__brawcap__receive.html#ga843f6d93dd1634d3059f967f3c219c6a">brawcap_rx_stop</a>, because parallel receives are not allowed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pHandle</td><td>bRAWcap handle to receive from.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>Function pointer to user application receive callback.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pUser</td><td>Pointer to a user defined context. Can be NULL if no user context is required.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indicateNoPackets</td><td>Specifies if callback is called even without any received data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Status   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group__brawcap__status.html#gga9c7e2713c1673acb5aab7c2d06ff481fa200dd935b65622249463189f7a6caf32">BRAWCAP_STATUS_SUCCESS</a>   </td><td class="markdownTableBodyNone">Success.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="group__brawcap__status.html#gga9c7e2713c1673acb5aab7c2d06ff481fa67cb41d5c4f828e746e586da186436ce">BRAWCAP_STATUS_ERROR_INVALID_POINTER</a>   </td><td class="markdownTableBodyNone">At least one of the given pointer parameters was invalid.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group__brawcap__status.html#gga9c7e2713c1673acb5aab7c2d06ff481fa7b5947d7cb66cf12afc410f255622eed">BRAWCAP_STATUS_WARNING_PENDING</a>   </td><td class="markdownTableBodyNone">Another receive is pending or reception is already started.   </td></tr>
</table>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="07_receive_buffered_receiver_8c-example.html#a16">07_receive_buffered_receiver.c</a>.</dd>
</dl>

</div>
</div>
<a id="ga843f6d93dd1634d3059f967f3c219c6a" name="ga843f6d93dd1634d3059f967f3c219c6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga843f6d93dd1634d3059f967f3c219c6a">&#9670;&#160;</a></span>brawcap_rx_stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__brawcap__status.html#ga9c7e2713c1673acb5aab7c2d06ff481f">brawcap_status_t</a> brawcap_rx_stop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__brawcap__generics.html#ga671085eed0374e88951b853f9eb027c1">brawcap_handle_t</a> *const&#160;</td>
          <td class="paramname"><em>pHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="brawcap_8h.html">brawcap.h</a>&gt;</code></p>

<p>Stops the internal receive loop. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pHandle</td><td>bRAWcap handle to stop reception.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Status   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group__brawcap__status.html#gga9c7e2713c1673acb5aab7c2d06ff481fa200dd935b65622249463189f7a6caf32">BRAWCAP_STATUS_SUCCESS</a>   </td><td class="markdownTableBodyNone">Success.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="group__brawcap__status.html#gga9c7e2713c1673acb5aab7c2d06ff481fa67cb41d5c4f828e746e586da186436ce">BRAWCAP_STATUS_ERROR_INVALID_POINTER</a>   </td><td class="markdownTableBodyNone">At least one of the given pointer parameters was invalid.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group__brawcap__status.html#gga9c7e2713c1673acb5aab7c2d06ff481fac093309781dc2e9b9932dbc40c511f68">BRAWCAP_STATUS_INFO_NOT_RUNNING</a>   </td><td class="markdownTableBodyNone">There was no receive running.   </td></tr>
</table>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="07_receive_buffered_receiver_8c-example.html#a17">07_receive_buffered_receiver.c</a>.</dd>
</dl>

</div>
</div>
<a id="gaa94f01c13b4fd705bb6c76fc8422d118" name="gaa94f01c13b4fd705bb6c76fc8422d118"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa94f01c13b4fd705bb6c76fc8422d118">&#9670;&#160;</a></span>brawcap_rx_buffer_attach()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__brawcap__status.html#ga9c7e2713c1673acb5aab7c2d06ff481f">brawcap_status_t</a> brawcap_rx_buffer_attach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__brawcap__generics.html#ga671085eed0374e88951b853f9eb027c1">brawcap_handle_t</a> *const&#160;</td>
          <td class="paramname"><em>pHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__brawcap__buffer.html#ga0b3e0af30a05c842f801a981ffd19582">brawcap_buffer_t</a> *const&#160;</td>
          <td class="paramname"><em>pBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="brawcap_8h.html">brawcap.h</a>&gt;</code></p>

<p>Attaches the specified bRAWcap packet buffer to the specified handle. </p>
<p>After attaching a packet buffer to a handle it will be used for receiving data on that handle. Data is only received if the internal receive loop was started/is running (with <a class="el" href="group__brawcap__receive.html#ga3754d5c0d8f4450c75b835c859393ee4">brawcap_rx_start</a>).</p>
<p>The buffer is locked until:</p><ul>
<li>It is detached from the handle with <a class="el" href="group__brawcap__receive.html#ga2fa3adba907d4f96c29a752656029151">brawcap_rx_buffer_detach</a>.</li>
<li>A receive has finished and the receive callback is called (buffer is not locked during callback execution).</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>A buffer can be attached only once and is than locked down by the handle it is attached to. This means that it has to be detached before it can be used again for another handle.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pHandle</td><td>bRAWcap handle for attaching the buffer.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pBuffer</td><td>Packet buffer to be attached.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Status   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group__brawcap__status.html#gga9c7e2713c1673acb5aab7c2d06ff481fa200dd935b65622249463189f7a6caf32">BRAWCAP_STATUS_SUCCESS</a>   </td><td class="markdownTableBodyNone">Success.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="group__brawcap__status.html#gga9c7e2713c1673acb5aab7c2d06ff481fa67cb41d5c4f828e746e586da186436ce">BRAWCAP_STATUS_ERROR_INVALID_POINTER</a>   </td><td class="markdownTableBodyNone">At least one of the given pointer parameters was invalid.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group__brawcap__status.html#gga9c7e2713c1673acb5aab7c2d06ff481fa1483743d4d66e1546756da1313b62edf">BRAWCAP_STATUS_ERROR_IN_USE</a>   </td><td class="markdownTableBodyNone">The buffer is already in use / locked down by another operation.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="group__brawcap__status.html#gga9c7e2713c1673acb5aab7c2d06ff481fa3d498fe7b5765be8ac8d3bc935a15804">BRAWCAP_STATUS_WARNING_LIMIT_REACHED</a>   </td><td class="markdownTableBodyNone">Limitation of buffer per handle reached (<a class="el" href="group__brawcap__receive.html#gab5791bfef9bbb31dab119907bf1fb261">BRAWCAP_RX_BUFFERS_PER_HANDLE_MAX</a>)   </td></tr>
</table>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="07_receive_buffered_receiver_8c-example.html#a15">07_receive_buffered_receiver.c</a>.</dd>
</dl>

</div>
</div>
<a id="ga2fa3adba907d4f96c29a752656029151" name="ga2fa3adba907d4f96c29a752656029151"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2fa3adba907d4f96c29a752656029151">&#9670;&#160;</a></span>brawcap_rx_buffer_detach()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__brawcap__status.html#ga9c7e2713c1673acb5aab7c2d06ff481f">brawcap_status_t</a> brawcap_rx_buffer_detach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__brawcap__generics.html#ga671085eed0374e88951b853f9eb027c1">brawcap_handle_t</a> *const&#160;</td>
          <td class="paramname"><em>pHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__brawcap__buffer.html#ga0b3e0af30a05c842f801a981ffd19582">brawcap_buffer_t</a> *const&#160;</td>
          <td class="paramname"><em>pBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="brawcap_8h.html">brawcap.h</a>&gt;</code></p>

<p>Detaches the specified bRAWcap packet buffer from the specified handle. </p>
<p>After detaching a buffer it is unlocked and can be accessed/modified. It can also be reused for another operation or freed with <a class="el" href="group__brawcap__buffer.html#ga5899723ba8903f6ee7ee0257b926eccb">brawcap_buffer_free</a> if it is not required anymore.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pHandle</td><td>bRAWcap handle from which the buffer is to be detached.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pBuffer</td><td>Packet buffer to be detached.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Status   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group__brawcap__status.html#gga9c7e2713c1673acb5aab7c2d06ff481fa200dd935b65622249463189f7a6caf32">BRAWCAP_STATUS_SUCCESS</a>   </td><td class="markdownTableBodyNone">Success.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="group__brawcap__status.html#gga9c7e2713c1673acb5aab7c2d06ff481fa67cb41d5c4f828e746e586da186436ce">BRAWCAP_STATUS_ERROR_INVALID_POINTER</a>   </td><td class="markdownTableBodyNone">At least one of the given pointer parameters was invalid.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group__brawcap__status.html#gga9c7e2713c1673acb5aab7c2d06ff481fa0bf07aa9ec83492a00fd1df04f3835aa">BRAWCAP_STATUS_INFO_NOT_ATTACHED</a>   </td><td class="markdownTableBodyNone">The buffer was not attached.   </td></tr>
</table>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="07_receive_buffered_receiver_8c-example.html#a18">07_receive_buffered_receiver.c</a>.</dd>
</dl>

</div>
</div>
<a id="ga7eb9a5a77e7e0bdf07b863d870f7a2b9" name="ga7eb9a5a77e7e0bdf07b863d870f7a2b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7eb9a5a77e7e0bdf07b863d870f7a2b9">&#9670;&#160;</a></span>brawcap_rx_direction_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__brawcap__status.html#ga9c7e2713c1673acb5aab7c2d06ff481f">brawcap_status_t</a> brawcap_rx_direction_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__brawcap__generics.html#ga671085eed0374e88951b853f9eb027c1">brawcap_handle_t</a> *const&#160;</td>
          <td class="paramname"><em>pHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__brawcap__receive.html#gaf535438d62a0685378b5da61af35a3d9">brawcap_rx_direction_t</a>&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="brawcap_8h.html">brawcap.h</a>&gt;</code></p>

<p>Sets the receive direction for the specified handle. </p>
<p>Possible directions are:</p><ul>
<li><a class="el" href="group__brawcap__receive.html#ggaf535438d62a0685378b5da61af35a3d9a380d9e7ce5d8288cf928f308b2991570">BRAWCAP_RX_DIRECTION_UNKNOWN</a></li>
<li><a class="el" href="group__brawcap__receive.html#ggaf535438d62a0685378b5da61af35a3d9a73d2c6837bf71a6edf384212e04880d7">BRAWCAP_RX_DIRECTION_IN</a></li>
<li><a class="el" href="group__brawcap__receive.html#ggaf535438d62a0685378b5da61af35a3d9ab06dbb4df86375e190a68d8c1c9ea5af">BRAWCAP_RX_DIRECTION_OUT</a></li>
<li><a class="el" href="group__brawcap__receive.html#ggaf535438d62a0685378b5da61af35a3d9ae00b6187141913c18746b789cff375ea">BRAWCAP_RX_DIRECTION_BOTH</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pHandle</td><td>bRAWcap handle to be configured.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">direction</td><td>The direction to be set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Status   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group__brawcap__status.html#gga9c7e2713c1673acb5aab7c2d06ff481fa200dd935b65622249463189f7a6caf32">BRAWCAP_STATUS_SUCCESS</a>   </td><td class="markdownTableBodyNone">Success.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="group__brawcap__status.html#gga9c7e2713c1673acb5aab7c2d06ff481fa67cb41d5c4f828e746e586da186436ce">BRAWCAP_STATUS_ERROR_INVALID_POINTER</a>   </td><td class="markdownTableBodyNone">At least one of the given pointer parameters was invalid.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group__brawcap__status.html#gga9c7e2713c1673acb5aab7c2d06ff481fa318dec04646ebef9e4ec33318790bb17">BRAWCAP_STATUS_ERROR_DRIVER_IO_FAILED</a>   </td><td class="markdownTableBodyNone">Communicating with bRAWcap driver failed.   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="ga1ffedb21061d52bf98bc4a9ff3b52d82" name="ga1ffedb21061d52bf98bc4a9ff3b52d82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ffedb21061d52bf98bc4a9ff3b52d82">&#9670;&#160;</a></span>brawcap_rx_direction_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__brawcap__status.html#ga9c7e2713c1673acb5aab7c2d06ff481f">brawcap_status_t</a> brawcap_rx_direction_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__brawcap__generics.html#ga671085eed0374e88951b853f9eb027c1">brawcap_handle_t</a> *const&#160;</td>
          <td class="paramname"><em>pHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__brawcap__receive.html#gaf535438d62a0685378b5da61af35a3d9">brawcap_rx_direction_t</a> *const&#160;</td>
          <td class="paramname"><em>pDirection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="brawcap_8h.html">brawcap.h</a>&gt;</code></p>

<p>Reads out the currently configured receive direction of the specified handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pHandle</td><td>bRAWcap handle to read from.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pDirection</td><td>Will contain the currently configured receive direction, afterwards.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Status   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group__brawcap__status.html#gga9c7e2713c1673acb5aab7c2d06ff481fa200dd935b65622249463189f7a6caf32">BRAWCAP_STATUS_SUCCESS</a>   </td><td class="markdownTableBodyNone">Success.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="group__brawcap__status.html#gga9c7e2713c1673acb5aab7c2d06ff481fa67cb41d5c4f828e746e586da186436ce">BRAWCAP_STATUS_ERROR_INVALID_POINTER</a>   </td><td class="markdownTableBodyNone">At least one of the given pointer parameters was invalid.   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="ga097337afa32a171a7d17b267d2aafebc" name="ga097337afa32a171a7d17b267d2aafebc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga097337afa32a171a7d17b267d2aafebc">&#9670;&#160;</a></span>brawcap_rx_min_packets_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__brawcap__status.html#ga9c7e2713c1673acb5aab7c2d06ff481f">brawcap_status_t</a> brawcap_rx_min_packets_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__brawcap__generics.html#ga671085eed0374e88951b853f9eb027c1">brawcap_handle_t</a> *const&#160;</td>
          <td class="paramname"><em>pHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__brawcap__receive.html#gac71dec73f7c59bc09a291dd02b27310e">brawcap_rx_min_packets_t</a>&#160;</td>
          <td class="paramname"><em>minPackets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="brawcap_8h.html">brawcap.h</a>&gt;</code></p>

<p>Sets the minimum amount of packets to receive for the specified handle. </p>
<p>This value influences how often the bRAWcap driver will return pending receives. It forces the driver to stay in the request as long as not the minimum amount of packets were captured. Setting a higher value here can reduce the overall system load but increases also the responsiveness/latency when the packet was received by the adapter and the indication of the packet to the caller. The initial/default value is set to <a class="el" href="group__brawcap__receive.html#ga72ee682689c05040c162d674238aeb02">BRAWCAP_RX_COPY_PACKETS_DEFAULT</a>.</p>
<dl class="section invariant"><dt>Invariant</dt><dd>If high receive rates should be reached (and many packets coming in), a high value is preferred. Otherwise if low latency is required the best effort would be to set this value to zero.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Independent from this value the receive will at least return if it pends for 10 times the configured receive timeout. This avoid infinite blocking (infinite blocking is only the possible if the receive timeout is zero). If this value is set to zero it will always return after the first receive timeout. And if the given buffer becomes filled up before the timeout is reached it will return when the buffer is full.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pHandle</td><td>bRAWcap handle to be configured.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">minPackets</td><td>The minimum amount of packets to receive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Status   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group__brawcap__status.html#gga9c7e2713c1673acb5aab7c2d06ff481fa200dd935b65622249463189f7a6caf32">BRAWCAP_STATUS_SUCCESS</a>   </td><td class="markdownTableBodyNone">Success.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="group__brawcap__status.html#gga9c7e2713c1673acb5aab7c2d06ff481fa67cb41d5c4f828e746e586da186436ce">BRAWCAP_STATUS_ERROR_INVALID_POINTER</a>   </td><td class="markdownTableBodyNone">At least one of the given pointer parameters was invalid.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group__brawcap__status.html#gga9c7e2713c1673acb5aab7c2d06ff481fa318dec04646ebef9e4ec33318790bb17">BRAWCAP_STATUS_ERROR_DRIVER_IO_FAILED</a>   </td><td class="markdownTableBodyNone">Communicating with bRAWcap driver failed.   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="gac44d8a782c2001ee540dad4c45373cab" name="gac44d8a782c2001ee540dad4c45373cab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac44d8a782c2001ee540dad4c45373cab">&#9670;&#160;</a></span>brawcap_rx_min_packets_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__brawcap__status.html#ga9c7e2713c1673acb5aab7c2d06ff481f">brawcap_status_t</a> brawcap_rx_min_packets_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__brawcap__generics.html#ga671085eed0374e88951b853f9eb027c1">brawcap_handle_t</a> *const&#160;</td>
          <td class="paramname"><em>pHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__brawcap__receive.html#gac71dec73f7c59bc09a291dd02b27310e">brawcap_rx_min_packets_t</a> *const&#160;</td>
          <td class="paramname"><em>pMinPackets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="brawcap_8h.html">brawcap.h</a>&gt;</code></p>

<p>Reads out the currently configured number of packets to receive for the specified handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pHandle</td><td>bRAWcap handle to read from.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pMinPackets</td><td>Will contain the configured minimum amount of packets per receive, afterwards.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Status   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group__brawcap__status.html#gga9c7e2713c1673acb5aab7c2d06ff481fa200dd935b65622249463189f7a6caf32">BRAWCAP_STATUS_SUCCESS</a>   </td><td class="markdownTableBodyNone">Success.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="group__brawcap__status.html#gga9c7e2713c1673acb5aab7c2d06ff481fa67cb41d5c4f828e746e586da186436ce">BRAWCAP_STATUS_ERROR_INVALID_POINTER</a>   </td><td class="markdownTableBodyNone">At least one of the given pointer parameters was invalid.   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="ga5a7ccf66c3a4672304e6ea32e9da0e4f" name="ga5a7ccf66c3a4672304e6ea32e9da0e4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a7ccf66c3a4672304e6ea32e9da0e4f">&#9670;&#160;</a></span>brawcap_rx_timeout_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__brawcap__status.html#ga9c7e2713c1673acb5aab7c2d06ff481f">brawcap_status_t</a> brawcap_rx_timeout_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__brawcap__generics.html#ga671085eed0374e88951b853f9eb027c1">brawcap_handle_t</a> *const&#160;</td>
          <td class="paramname"><em>pHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__brawcap__receive.html#gaed97945884371959a33e46daa7c7181b">brawcap_rx_timeout_t</a>&#160;</td>
          <td class="paramname"><em>timeout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="brawcap_8h.html">brawcap.h</a>&gt;</code></p>

<p>Configures the receive timeout for the specified handle. </p>
<p>It´s guaranteed that receive functions will return at least after the specified timeout value, if the configured amount of packets value <a class="el" href="group__brawcap__receive.html#gac71dec73f7c59bc09a291dd02b27310e">brawcap_rx_min_packets_t</a> is reached before. If the configured amount of packets are not reached until the timeout occurs, the driver will stay in the request for up to 10 times of the specified timeout time until it final returns. It is also possible to specify a timeout of zero. A timeout of zero is equivalent to "no timeout".</p>
<dl class="section note"><dt>Note</dt><dd>Default timeout value is <a class="el" href="group__brawcap__receive.html#ga4788e60f3255029234090351bd4b9ea9">BRAWCAP_RX_TIMEOUT_MS_DEFAULT</a>. And the max supported timeout is <a class="el" href="group__brawcap__receive.html#gadb54bac4f649ab4eabbd68ccadda344d">BRAWCAP_RX_TIMEOUT_MS_MAX</a>.</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Be careful in using infinite timeouts. It could lead to a endless blocking behaviour. For example if there are no packets received which meet your configured filter on the underlying adapter.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pHandle</td><td>bRAWcap handle to be configured.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout_ms</td><td>Receive timeout in milliseconds to be set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Status   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group__brawcap__status.html#gga9c7e2713c1673acb5aab7c2d06ff481fa200dd935b65622249463189f7a6caf32">BRAWCAP_STATUS_SUCCESS</a>   </td><td class="markdownTableBodyNone">Success.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="group__brawcap__status.html#gga9c7e2713c1673acb5aab7c2d06ff481fa67cb41d5c4f828e746e586da186436ce">BRAWCAP_STATUS_ERROR_INVALID_POINTER</a>   </td><td class="markdownTableBodyNone">At least one of the given pointer parameters was invalid.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group__brawcap__status.html#gga9c7e2713c1673acb5aab7c2d06ff481fa5e8c73946b04c321cd81cdd35d2d812e">BRAWCAP_STATUS_ERROR_PARAM_OUT_OF_RANGE</a>   </td><td class="markdownTableBodyNone">The specified timeout value is invalid/out of range.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="group__brawcap__status.html#gga9c7e2713c1673acb5aab7c2d06ff481fa318dec04646ebef9e4ec33318790bb17">BRAWCAP_STATUS_ERROR_DRIVER_IO_FAILED</a>   </td><td class="markdownTableBodyNone">Communicating with bRAWcap driver failed.   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="ga33f42d5a8d31fc0ba7c515646c6c0663" name="ga33f42d5a8d31fc0ba7c515646c6c0663"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33f42d5a8d31fc0ba7c515646c6c0663">&#9670;&#160;</a></span>brawcap_rx_timeout_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__brawcap__status.html#ga9c7e2713c1673acb5aab7c2d06ff481f">brawcap_status_t</a> brawcap_rx_timeout_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__brawcap__generics.html#ga671085eed0374e88951b853f9eb027c1">brawcap_handle_t</a> *const&#160;</td>
          <td class="paramname"><em>pHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__brawcap__receive.html#gaed97945884371959a33e46daa7c7181b">brawcap_rx_timeout_t</a> *const&#160;</td>
          <td class="paramname"><em>pTimeout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="brawcap_8h.html">brawcap.h</a>&gt;</code></p>

<p>Reads out the currently configured receive timeout for the specified handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pHandle</td><td>bRAWcap handle to read from.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pTimeout_ms</td><td>Will contain the configured receive timeout in milliseconds, afterwards.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Status   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group__brawcap__status.html#gga9c7e2713c1673acb5aab7c2d06ff481fa200dd935b65622249463189f7a6caf32">BRAWCAP_STATUS_SUCCESS</a>   </td><td class="markdownTableBodyNone">Success.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="group__brawcap__status.html#gga9c7e2713c1673acb5aab7c2d06ff481fa67cb41d5c4f828e746e586da186436ce">BRAWCAP_STATUS_ERROR_INVALID_POINTER</a>   </td><td class="markdownTableBodyNone">At least one of the given pointer parameters was invalid.   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="gaac08bee873c62ebb138797c12e52bebb" name="gaac08bee873c62ebb138797c12e52bebb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac08bee873c62ebb138797c12e52bebb">&#9670;&#160;</a></span>brawcap_rx_filter_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__brawcap__status.html#ga9c7e2713c1673acb5aab7c2d06ff481f">brawcap_status_t</a> brawcap_rx_filter_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__brawcap__generics.html#ga671085eed0374e88951b853f9eb027c1">brawcap_handle_t</a> *const&#160;</td>
          <td class="paramname"><em>pHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__brawcap__filter.html#ga4225c6360a481d7051e5d81045eb8d22">brawcap_filter_t</a> *const&#160;</td>
          <td class="paramname"><em>pFilter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="brawcap_8h.html">brawcap.h</a>&gt;</code></p>

<p>Sets the specified filter to the specified handle. </p>
<p>For more information on filters see <a class="el" href="group__brawcap__filter.html#ga4225c6360a481d7051e5d81045eb8d22">brawcap_filter_t</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Each handle can have exactly one filter applied. If several filters shall be applied to the same adapter, it is required to open several bRAWcap handles to the same adapter.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pHandle</td><td>bRAWcap handle to be modified.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pFilter</td><td>The filter to set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Status   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group__brawcap__status.html#gga9c7e2713c1673acb5aab7c2d06ff481fa200dd935b65622249463189f7a6caf32">BRAWCAP_STATUS_SUCCESS</a>   </td><td class="markdownTableBodyNone">Success.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="group__brawcap__status.html#gga9c7e2713c1673acb5aab7c2d06ff481fa67cb41d5c4f828e746e586da186436ce">BRAWCAP_STATUS_ERROR_INVALID_POINTER</a>   </td><td class="markdownTableBodyNone">At least one of the given pointer parameters was invalid.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group__brawcap__status.html#gga9c7e2713c1673acb5aab7c2d06ff481fa318dec04646ebef9e4ec33318790bb17">BRAWCAP_STATUS_ERROR_DRIVER_IO_FAILED</a>   </td><td class="markdownTableBodyNone">Communicating with bRAWcap driver failed.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="group__brawcap__status.html#gga9c7e2713c1673acb5aab7c2d06ff481facf0a3e5a7707d6dffe88cb1f22e14c30">BRAWCAP_STATUS_ERROR_NOT_AVAILABLE</a>   </td><td class="markdownTableBodyNone">Specified filter type is not available.   </td></tr>
</table>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="06_filter_firewall_8c-example.html#a14">06_filter_firewall.c</a>.</dd>
</dl>

</div>
</div>
<a id="gacc92c0d0fe9e2ba5719798c9fdbd9d16" name="gacc92c0d0fe9e2ba5719798c9fdbd9d16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc92c0d0fe9e2ba5719798c9fdbd9d16">&#9670;&#160;</a></span>brawcap_rx_filter_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__brawcap__status.html#ga9c7e2713c1673acb5aab7c2d06ff481f">brawcap_status_t</a> brawcap_rx_filter_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__brawcap__generics.html#ga671085eed0374e88951b853f9eb027c1">brawcap_handle_t</a> *const&#160;</td>
          <td class="paramname"><em>pHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__brawcap__filter.html#ga4225c6360a481d7051e5d81045eb8d22">brawcap_filter_t</a> *const&#160;</td>
          <td class="paramname"><em>pFilter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="brawcap_8h.html">brawcap.h</a>&gt;</code></p>

<p>Reads out the currently configured filter for the specified handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pHandle</td><td>bRAWcap handle to read from.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pFilter</td><td>Will contain the currently configured filter, afterwards.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Status   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group__brawcap__status.html#gga9c7e2713c1673acb5aab7c2d06ff481fa200dd935b65622249463189f7a6caf32">BRAWCAP_STATUS_SUCCESS</a>   </td><td class="markdownTableBodyNone">Success.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="group__brawcap__status.html#gga9c7e2713c1673acb5aab7c2d06ff481fa67cb41d5c4f828e746e586da186436ce">BRAWCAP_STATUS_ERROR_INVALID_POINTER</a>   </td><td class="markdownTableBodyNone">At least one of the given pointer parameters was invalid.   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="ga8048f83ce46971a2b16e20ec7f08c4c6" name="ga8048f83ce46971a2b16e20ec7f08c4c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8048f83ce46971a2b16e20ec7f08c4c6">&#9670;&#160;</a></span>brawcap_rx_promiscuous_mode_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__brawcap__status.html#ga9c7e2713c1673acb5aab7c2d06ff481f">brawcap_status_t</a> brawcap_rx_promiscuous_mode_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__brawcap__generics.html#ga671085eed0374e88951b853f9eb027c1">brawcap_handle_t</a> *const&#160;</td>
          <td class="paramname"><em>pHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BOOLEAN&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="brawcap_8h.html">brawcap.h</a>&gt;</code></p>

<p>Sets the current promiscuous mode flag for the specified handle. </p>
<p>If a adapter is set into promiscuous mode it receives not only packages which directly address the adapter. This can be used for recording/sniffing purposes but increases the local system load. Promiscuous mode is a network adapter feature and which can only be modified by bRAWcap. Therefore it is not specific to a bRAWcap handle. Instead it is a per adapter setting which can also be modified from another application.</p>
<dl class="section note"><dt>Note</dt><dd>Promiscuous mode will be reset automatically upon deleting the corresponding handle. Which means if it was activated due to the bRAWcap handle it will be disabled again when the handle is closed.</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Because of the per adapter scope, promiscuous mode can not explicitly modified by bRAWcap. Instead if at least one application or another bRAWcap handle activated it, it will stay enabled until the last application/handle which has activated it, is closed or deactivates it again.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pHandle</td><td>bRAWcap handle to be modified.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enable</td><td>Promiscuous mode state to be set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Status   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group__brawcap__status.html#gga9c7e2713c1673acb5aab7c2d06ff481fa200dd935b65622249463189f7a6caf32">BRAWCAP_STATUS_SUCCESS</a>   </td><td class="markdownTableBodyNone">Success.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="group__brawcap__status.html#gga9c7e2713c1673acb5aab7c2d06ff481fa67cb41d5c4f828e746e586da186436ce">BRAWCAP_STATUS_ERROR_INVALID_POINTER</a>   </td><td class="markdownTableBodyNone">At least one of the given pointer parameters was invalid.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group__brawcap__status.html#gga9c7e2713c1673acb5aab7c2d06ff481fa318dec04646ebef9e4ec33318790bb17">BRAWCAP_STATUS_ERROR_DRIVER_IO_FAILED</a>   </td><td class="markdownTableBodyNone">Communicating with bRAWcap driver failed.   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="ga93e4c6389eea2a8f516fc6e6f86fc2ae" name="ga93e4c6389eea2a8f516fc6e6f86fc2ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93e4c6389eea2a8f516fc6e6f86fc2ae">&#9670;&#160;</a></span>brawcap_rx_promiscuous_mode_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__brawcap__status.html#ga9c7e2713c1673acb5aab7c2d06ff481f">brawcap_status_t</a> brawcap_rx_promiscuous_mode_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__brawcap__generics.html#ga671085eed0374e88951b853f9eb027c1">brawcap_handle_t</a> *const&#160;</td>
          <td class="paramname"><em>pHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOLEAN *const&#160;</td>
          <td class="paramname"><em>pEnabled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOLEAN *const&#160;</td>
          <td class="paramname"><em>pEnabledAdapter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="brawcap_8h.html">brawcap.h</a>&gt;</code></p>

<p>Reads out the current promiscuous mode state for the specified handle. </p>
<p>Additionally to the promiscuous state of the handle itself it also reads the current promiscuous state of to the underlying adapter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pHandle</td><td>bRAWcap handle to read from.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pEnabled</td><td>Will contain the current promiscuous mode state of the handle, afterwards.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pEnabledAdapter</td><td>Will contain the current promiscuous mode state of the underlying adapter, afterwards.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Status   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group__brawcap__status.html#gga9c7e2713c1673acb5aab7c2d06ff481fa200dd935b65622249463189f7a6caf32">BRAWCAP_STATUS_SUCCESS</a>   </td><td class="markdownTableBodyNone">Success.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="group__brawcap__status.html#gga9c7e2713c1673acb5aab7c2d06ff481fa67cb41d5c4f828e746e586da186436ce">BRAWCAP_STATUS_ERROR_INVALID_POINTER</a>   </td><td class="markdownTableBodyNone">At least one of the given pointer parameters was invalid.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group__brawcap__status.html#gga9c7e2713c1673acb5aab7c2d06ff481fa318dec04646ebef9e4ec33318790bb17">BRAWCAP_STATUS_ERROR_DRIVER_IO_FAILED</a>   </td><td class="markdownTableBodyNone">Communicating with bRAWcap driver failed.   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="ga79d75083f93e69a323afc78668ffd38c" name="ga79d75083f93e69a323afc78668ffd38c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79d75083f93e69a323afc78668ffd38c">&#9670;&#160;</a></span>brawcap_rx_timestamp_capabilities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__brawcap__status.html#ga9c7e2713c1673acb5aab7c2d06ff481f">brawcap_status_t</a> brawcap_rx_timestamp_capabilities </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__brawcap__generics.html#ga671085eed0374e88951b853f9eb027c1">brawcap_handle_t</a> *const&#160;</td>
          <td class="paramname"><em>pHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__brawcap__timestamp.html#ga2e576ed8155bf55660489ea9406a69d5">brawcap_timestamp_capabilities_t</a> *const&#160;</td>
          <td class="paramname"><em>pCapabilities</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="brawcap_8h.html">brawcap.h</a>&gt;</code></p>

<p>Reads out the available receive timestamp modes for the specified handle. </p>
<p>Some of the timestamp capabilites depend on the features provided by the underlying adapter. Those modes are named with "adapter".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pHandle</td><td>bRAWcap handle to read from.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pCapabilities</td><td>Will contain the available receive timestamp modes, afterwards.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Status   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group__brawcap__status.html#gga9c7e2713c1673acb5aab7c2d06ff481fa200dd935b65622249463189f7a6caf32">BRAWCAP_STATUS_SUCCESS</a>   </td><td class="markdownTableBodyNone">Success.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="group__brawcap__status.html#gga9c7e2713c1673acb5aab7c2d06ff481fa67cb41d5c4f828e746e586da186436ce">BRAWCAP_STATUS_ERROR_INVALID_POINTER</a>   </td><td class="markdownTableBodyNone">At least one of the given pointer parameters was invalid.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group__brawcap__status.html#gga9c7e2713c1673acb5aab7c2d06ff481fa318dec04646ebef9e4ec33318790bb17">BRAWCAP_STATUS_ERROR_DRIVER_IO_FAILED</a>   </td><td class="markdownTableBodyNone">Communicating with bRAWcap driver failed.   </td></tr>
</table>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="08_receive_timestamp_inspector_8c-example.html#a14">08_receive_timestamp_inspector.c</a>.</dd>
</dl>

</div>
</div>
<a id="gae642dce7272a00c24a539f7e605c98d6" name="gae642dce7272a00c24a539f7e605c98d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae642dce7272a00c24a539f7e605c98d6">&#9670;&#160;</a></span>brawcap_rx_timestamp_mode_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__brawcap__status.html#ga9c7e2713c1673acb5aab7c2d06ff481f">brawcap_status_t</a> brawcap_rx_timestamp_mode_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__brawcap__generics.html#ga671085eed0374e88951b853f9eb027c1">brawcap_handle_t</a> *const&#160;</td>
          <td class="paramname"><em>pHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__brawcap__timestamp.html#ga98151584e36542e2e1f0defff54cb4f9">brawcap_timestamp_mode_t</a> *const&#160;</td>
          <td class="paramname"><em>pMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="brawcap_8h.html">brawcap.h</a>&gt;</code></p>

<p>Reads out the currently configured receive time stamping mode for the specified handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pHandle</td><td>bRAWcap handle to read from.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pMode</td><td>Will contain the currently used receive time stamping mode, afterwards.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Status   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group__brawcap__status.html#gga9c7e2713c1673acb5aab7c2d06ff481fa200dd935b65622249463189f7a6caf32">BRAWCAP_STATUS_SUCCESS</a>   </td><td class="markdownTableBodyNone">Success.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="group__brawcap__status.html#gga9c7e2713c1673acb5aab7c2d06ff481fa67cb41d5c4f828e746e586da186436ce">BRAWCAP_STATUS_ERROR_INVALID_POINTER</a>   </td><td class="markdownTableBodyNone">At least one of the given pointer parameters was invalid.   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="gaa1d6bed398e0b10376cc0e93528cfe5f" name="gaa1d6bed398e0b10376cc0e93528cfe5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1d6bed398e0b10376cc0e93528cfe5f">&#9670;&#160;</a></span>brawcap_rx_timestamp_mode_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__brawcap__status.html#ga9c7e2713c1673acb5aab7c2d06ff481f">brawcap_status_t</a> brawcap_rx_timestamp_mode_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__brawcap__generics.html#ga671085eed0374e88951b853f9eb027c1">brawcap_handle_t</a> *const&#160;</td>
          <td class="paramname"><em>pHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__brawcap__timestamp.html#ga98151584e36542e2e1f0defff54cb4f9">brawcap_timestamp_mode_t</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="brawcap_8h.html">brawcap.h</a>&gt;</code></p>

<p>Configures the used receive time stamping mode for the specified handle. </p>
<dl class="section note"><dt>Note</dt><dd>Only available timestamp modes are accepted. It is recommended to check if a timestamp mode is supported before setting it. To check if a timestamp mode is available use <a class="el" href="group__brawcap__receive.html#ga79d75083f93e69a323afc78668ffd38c">brawcap_rx_timestamp_capabilities</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pHandle</td><td>bRAWcap handle to be configured.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mode</td><td>The receive timestamp mode to be configured.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Status   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group__brawcap__status.html#gga9c7e2713c1673acb5aab7c2d06ff481fa200dd935b65622249463189f7a6caf32">BRAWCAP_STATUS_SUCCESS</a>   </td><td class="markdownTableBodyNone">Success.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="group__brawcap__status.html#gga9c7e2713c1673acb5aab7c2d06ff481fa67cb41d5c4f828e746e586da186436ce">BRAWCAP_STATUS_ERROR_INVALID_POINTER</a>   </td><td class="markdownTableBodyNone">At least one of the given pointer parameters was invalid.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group__brawcap__status.html#gga9c7e2713c1673acb5aab7c2d06ff481facf0a3e5a7707d6dffe88cb1f22e14c30">BRAWCAP_STATUS_ERROR_NOT_AVAILABLE</a>   </td><td class="markdownTableBodyNone">Specified timestamp mode not available.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="group__brawcap__status.html#gga9c7e2713c1673acb5aab7c2d06ff481fa318dec04646ebef9e4ec33318790bb17">BRAWCAP_STATUS_ERROR_DRIVER_IO_FAILED</a>   </td><td class="markdownTableBodyNone">Communicating with bRAWcap driver failed.   </td></tr>
</table>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="08_receive_timestamp_inspector_8c-example.html#a15">08_receive_timestamp_inspector.c</a>.</dd>
</dl>

</div>
</div>
<a id="ga70847c908de1210faab988a1f2ca0ccf" name="ga70847c908de1210faab988a1f2ca0ccf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga70847c908de1210faab988a1f2ca0ccf">&#9670;&#160;</a></span>brawcap_rx_vlan_tagging_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__brawcap__status.html#ga9c7e2713c1673acb5aab7c2d06ff481f">brawcap_status_t</a> brawcap_rx_vlan_tagging_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__brawcap__generics.html#ga671085eed0374e88951b853f9eb027c1">brawcap_handle_t</a> *const&#160;</td>
          <td class="paramname"><em>pHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BOOLEAN&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="brawcap_8h.html">brawcap.h</a>&gt;</code></p>

<p>Sets the current VLAN tagging flag for the specified handle. </p>
<p>If VLAN tagging is enabled, the VLAN Header (defined by IEEE 802.1Q) will be part of the packet payload. By default, the VLAN header is not included in the packet payload.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pHandle</td><td>bRAWcap handle to be configured.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enable</td><td>VLAN tagging state to be set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Status   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group__brawcap__status.html#gga9c7e2713c1673acb5aab7c2d06ff481fa200dd935b65622249463189f7a6caf32">BRAWCAP_STATUS_SUCCESS</a>   </td><td class="markdownTableBodyNone">Success.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="group__brawcap__status.html#gga9c7e2713c1673acb5aab7c2d06ff481fa67cb41d5c4f828e746e586da186436ce">BRAWCAP_STATUS_ERROR_INVALID_POINTER</a>   </td><td class="markdownTableBodyNone">At least one of the given pointer parameters was invalid.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group__brawcap__status.html#gga9c7e2713c1673acb5aab7c2d06ff481fa318dec04646ebef9e4ec33318790bb17">BRAWCAP_STATUS_ERROR_DRIVER_IO_FAILED</a>   </td><td class="markdownTableBodyNone">Communicating with bRAWcap driver failed.   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="ga511ecf7d0d33d9df949aeee86ab0238a" name="ga511ecf7d0d33d9df949aeee86ab0238a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga511ecf7d0d33d9df949aeee86ab0238a">&#9670;&#160;</a></span>brawcap_rx_vlan_tagging_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__brawcap__status.html#ga9c7e2713c1673acb5aab7c2d06ff481f">brawcap_status_t</a> brawcap_rx_vlan_tagging_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__brawcap__generics.html#ga671085eed0374e88951b853f9eb027c1">brawcap_handle_t</a> *const&#160;</td>
          <td class="paramname"><em>pHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOLEAN *const&#160;</td>
          <td class="paramname"><em>pEnabled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="brawcap_8h.html">brawcap.h</a>&gt;</code></p>

<p>Reads out the configured VLAN tagging state for the specified handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pHandle</td><td>bRAWcap handle to read from.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pEnabled</td><td>Will contain the currently configured VLAN tagging state, afterwards.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Status   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group__brawcap__status.html#gga9c7e2713c1673acb5aab7c2d06ff481fa200dd935b65622249463189f7a6caf32">BRAWCAP_STATUS_SUCCESS</a>   </td><td class="markdownTableBodyNone">Success.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="group__brawcap__status.html#gga9c7e2713c1673acb5aab7c2d06ff481fa67cb41d5c4f828e746e586da186436ce">BRAWCAP_STATUS_ERROR_INVALID_POINTER</a>   </td><td class="markdownTableBodyNone">At least one of the given pointer parameters was invalid.   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="ga519867331e1b09e42706793fe2b76b9b" name="ga519867331e1b09e42706793fe2b76b9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga519867331e1b09e42706793fe2b76b9b">&#9670;&#160;</a></span>brawcap_rx_driver_queue_size_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__brawcap__status.html#ga9c7e2713c1673acb5aab7c2d06ff481f">brawcap_status_t</a> brawcap_rx_driver_queue_size_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__brawcap__generics.html#ga671085eed0374e88951b853f9eb027c1">brawcap_handle_t</a> *const&#160;</td>
          <td class="paramname"><em>pHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__brawcap__generics.html#ga5333ed197831fcb54dc690a993eb7310">brawcap_queue_size_t</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="brawcap_8h.html">brawcap.h</a>&gt;</code></p>

<p>Sets the driver queue size (in number of packets) for the specified handle. </p>
<p>A larger driver queue can avoid packet drops for time gaps were no packet buffer is available. But setting large driver queues should only be done if really necessary, because it can consume a lot of memory. Because driver queues exist per handle, the total amount of consumed memory has to summed up for all open handles and their current configuration.</p>
<p>The driver queue size can be adjusted at any time.</p>
<dl class="section note"><dt>Note</dt><dd>The default queue size is </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__brawcap__receive.html#ga752565ca529d2a78f19396e4e92e2e03" title="Default size for driver receive queues in number of packets.">BRAWCAP_RX_DRIVER_QUEUE_SIZE_DEFAULT</a> (in number of packets). And its max limitation is </dd>
<dd>
<a class="el" href="group__brawcap__receive.html#gaac4188f1788c6e9489ba67685e89812d" title="Maximum size (in number of packets) supported for driver receive queues.">BRAWCAP_RX_DRIVER_QUEUE_SIZE_MAX</a> (in number of packets).</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Reducing the queue size during runtime may result in packet loss. This may be the case if there are more packets stored in the queue than the new size can accommodate.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pHandle</td><td>bRAWcap handle to be configured.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Driver receive queue size to be set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Status   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group__brawcap__status.html#gga9c7e2713c1673acb5aab7c2d06ff481fa200dd935b65622249463189f7a6caf32">BRAWCAP_STATUS_SUCCESS</a>   </td><td class="markdownTableBodyNone">Success.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="group__brawcap__status.html#gga9c7e2713c1673acb5aab7c2d06ff481fa67cb41d5c4f828e746e586da186436ce">BRAWCAP_STATUS_ERROR_INVALID_POINTER</a>   </td><td class="markdownTableBodyNone">At least one of the given pointer parameters was invalid.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group__brawcap__status.html#gga9c7e2713c1673acb5aab7c2d06ff481fa5e8c73946b04c321cd81cdd35d2d812e">BRAWCAP_STATUS_ERROR_PARAM_OUT_OF_RANGE</a>   </td><td class="markdownTableBodyNone">Specified queue size is out of range/invalid.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="group__brawcap__status.html#gga9c7e2713c1673acb5aab7c2d06ff481fa318dec04646ebef9e4ec33318790bb17">BRAWCAP_STATUS_ERROR_DRIVER_IO_FAILED</a>   </td><td class="markdownTableBodyNone">Communicating with bRAWcap driver failed.   </td></tr>
</table>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="06_filter_firewall_8c-example.html#a15">06_filter_firewall.c</a>.</dd>
</dl>

</div>
</div>
<a id="ga9fe06bea62401c32e686775e6d093874" name="ga9fe06bea62401c32e686775e6d093874"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9fe06bea62401c32e686775e6d093874">&#9670;&#160;</a></span>brawcap_rx_driver_queue_size_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__brawcap__status.html#ga9c7e2713c1673acb5aab7c2d06ff481f">brawcap_status_t</a> brawcap_rx_driver_queue_size_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__brawcap__generics.html#ga671085eed0374e88951b853f9eb027c1">brawcap_handle_t</a> *const&#160;</td>
          <td class="paramname"><em>pHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__brawcap__generics.html#ga5333ed197831fcb54dc690a993eb7310">brawcap_queue_size_t</a> *const&#160;</td>
          <td class="paramname"><em>pSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="brawcap_8h.html">brawcap.h</a>&gt;</code></p>

<p>Reads out the currently configured driver receive queue size for the specified handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pHandle</td><td>bRAWcap handle to read from.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pSize</td><td>Will contain the currently configured driver receive queue size, afterwards.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Status   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group__brawcap__status.html#gga9c7e2713c1673acb5aab7c2d06ff481fa200dd935b65622249463189f7a6caf32">BRAWCAP_STATUS_SUCCESS</a>   </td><td class="markdownTableBodyNone">Success.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="group__brawcap__status.html#gga9c7e2713c1673acb5aab7c2d06ff481fa67cb41d5c4f828e746e586da186436ce">BRAWCAP_STATUS_ERROR_INVALID_POINTER</a>   </td><td class="markdownTableBodyNone">At least one of the given pointer parameters was invalid.   </td></tr>
</table>
</dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<!-- BEGIN BPLUS MODIFICATIONS -->
<!-- Keep the footer clear (removes the default doxygen footer) -->
<!-- END BPLUS MODIFICATIONS -->
</body>
</html>
